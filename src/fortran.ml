open Printf
open Linda
open Cil

let enable = ref false
(*let parse = assert false*)
(*open Parsec*)

  
(*type namesapce = ((char*char) * typ) list                                                                                           *)
(*let show_namespace t = show_list (show_pair (show_pair string_of_char string_of_char) (const "")) t                                 *)
(*                                                                                                                                    *)
(*type common = string * string list                                                                                                  *)
(*                                                                                                                                    *)
(*module Parse = struct                                                                                                               *)
(*  open ParsecLazyList                                                                                                               *)
(*	let pNumber =                                                                                                                     *)
(*	  pNumber <|> pThen (fun _ n -> "-"^n) (pLit "-") pNumber                                                                         *)
(*  let pFloat = pSat (fun s -> try ignore (float_of_string s);true with _ -> false)                                                  *)
(*  let pFloat = pFloat <|> pThen (fun _ n -> "-"^n) (pLit "-") pFloat                                                                *)
(*                                                                                                                                    *)
(*	let pComma = pLit ","                                                                                                             *)
(*	let pSemicolon = pLit ":"                                                                                                         *)
(*	let open_ = pLit "("                                                                                                              *)
(*  let close = pLit ")"                                                                                                              *)
(*                                                                                                                                    *)
(*  let pIdent = pSat (fun s -> ExtChar.isAlpha s.[0] || s.[0] = '_')                                                                 *)
(*	let pType = pThen4 (fun _ t i _ ->                                                                                                *)
(*    match t,i with                                                                                                                  *)
(*      | "REAL","8" -> TFloat (FDouble,[])                                                                                           *)
(*      | "REAL","4" -> TFloat (FFloat,[])                                                                                            *)
(*      | "INTEGER","4" -> TInt (IInt,[])                                                                                             *)
(*      | "INTEGER","8" -> TInt (ILong,[])                                                                                            *)
(*      | "UNKNOWN","0" -> TVoid []                                                                                                   *)
(*    ) open_ pAny pNumber close                                                                                                      *)
(*	let pLetterRange = pThen3 (fun a _ b -> (char_of_string a,char_of_string b)) pAny (pLit "-") pAny                                 *)
(*	let pLetterRangeType =                                                                                                            *)
(*	  pThen3 (fun a _ t -> a,t ) pLetterRange pSemicolon pType                                                                        *)
(*	                                                                                                                                  *)
(*	let pNamespace =                                                                                                                  *)
(*	  pThen3 (fun _ _ l -> l) (pLit "Namespace") pSemicolon (zeroOrMore pLetterRangeType)                                             *)
(*                                                                                                                                    *)
(*  let pProcedureName =                                                                                                              *)
(*    pThen4 (fun _ _ _ s -> s) (pLit "procedure") (pLit "name") (pLit "=") pAny                                                      *)
(*                                                                                                                                    *)
(*                                                                                                                                    *)
(*  let pCommon =                                                                                                                     *)
(*    pThen6 (fun _ _ _ nm _ l -> nm,l) (pLit "common") pSemicolon (pLit "/") pAny (pLit "/") (zeroOrMoreWithSep pComma pAny)         *)
(*                                                                                                                                    *)
(*  let pSymbol =                                                                                                                     *)
(*    pThen6 (fun _ s t _ l _ -> (s,t,l)) (pLit "symbol") pIdent pType open_ (zeroOrMore (pSat ((<>) ")"))) close                     *)
(*  let pResult =                                                                                                                     *)
(*    pThen3 (fun _ _ s -> s) (pLit "result") (pLit ":") pIdent                                                                       *)
(*  let pArrayDim =                                                                                                                   *)
(*    fmap (fun x -> Some x) pNumber <|> pThen (fun _ _ -> None) open_ close                                                          *)
(*  let pArrayDimSpec =                                                                                                               *)
(*    pThen3 (fun n t l -> n,t,l) pNumber (pLit "AS_EXPLICIT" <|> pLit "AS_ASSUMED_SIZE") (oneOrMore (pThen pair pArrayDim pArrayDim))*)
(*  let pArraySpec =                                                                                                                  *)
(*    pThen6 (fun _ _ _ _ ad _ -> ad) (pLit "Array") (pLit "spec") pSemicolon open_ pArrayDimSpec close                               *)
(*  let pValue = pThen3 (fun _ _ n -> n) (pLit "value") pSemicolon pNumber                                                            *)
(*  let pSymTree =                                                                                                                    *)
(*    pThen9 (fun _ _ s _ i (s',t,l) ro aso vo ->                                                                                     *)
(*      assert (s=s');                                                                                                                *)
(*(*      if List.mem "VARIABLE" l then*)                                                                                             *)
(*        makeVarinfo false s (TVoid [])                                                                                              *)
(*      ) (pLit "symtree") pSemicolon pIdent (pLit "Ambig") pNumber pSymbol                                                           *)
(*            (zeroOrOne pResult) (zeroOrOne pArraySpec) (zeroOrOne pValue)                                                           *)
(*                                                                                                                                    *)
(*  let pVariable =                                                                                                                   *)
(*    pThen3 (fun _ _ s -> s) pIdent pSemicolon pIdent <|> pIdent                                                                     *)
(*  let idVarinfoTable = Hashtbl.create 3                                                                                             *)
(*  let getVarinfo id =                                                                                                               *)
(*    try Hashtbl.find idVarinfoTable id with Not_found -> makeVarinfo false id (TVoid [])                                            *)
(*  let pConst =                                                                                                                      *)
(*    fmap (fun s -> CInt64 (Int64.of_string s,IInt,None)) pNumber                                                                    *)
(*    <|> fmap (fun s -> CReal (float_of_string s,FDouble,None)) pFloat                                                               *)
(*    <|> fmap (fun s -> CStr s) @$ pSat (fun s -> s.[0]='\'')                                                                        *)
(*                                                                                                                                    *)
(*  let rec pExp s =                                                                                                                  *)
(*    (fmap (fun x -> Lval x) pLval                                                                                                   *)
(*    <|> fmap (fun x -> Const x) pConst                                                                                              *)
(*(*    <|> fmap (f) pIntrinsic*)                                                                                                     *)
(*    ) s                                                                                                                             *)
(*  and pLval =                                                                                                                       *)
(*    pThen4 (fun v _ idx _ ->                                                                                                        *)
(*      Var (getVarinfo v),Index (Lval (Var (getVarinfo idx),NoOffset),NoOffset)) pVariable open_ pVariable close                     *)
(*      <|> fmap (fun v -> Var (getVarinfo v),NoOffset) pVariable                                                                     *)
(*  and pIntrinsic s =                                                                                                                *)
(*    (pThen4 (fun v _ es _ -> mkStmtOneInstr @$ Call (None, (Lval (Var (getVarinfo v),NoOffset)),es,locUnknown))                     *)
(*        pIdent (pLit "[[(") (zeroOrMore (pThen3 (fun _ e _ -> e) open_ pExp close)) (pLit ")]]")) s                                 *)
(*                                                                                                                                    *)
(*  let pAssignParameter name p = pThen3 (fun _ _ d -> d) (pLit name) (pLit "=") p                                                    *)
(*  let pUnit = pAssignParameter "UNIT" pNumber                                                                                       *)
(*  let pFmt = pAssignParameter "FMT" pNumber                                                                                         *)
(*  let pFile = pAssignParameter "FILE" pAny                                                                                          *)
(*  let pStatus = pAssignParameter "STATUS" pAny                                                                                      *)
(*                                                                                                                                    *)
(*  let pTransfer = pThen (fun _ e -> e) (pLit "TRANSFER") pExp                                                                       *)
(*  let pIORW =                                                                                                                       *)
(*    pThen5 (fun t u fmt trs _ ->                                                                                                    *)
(*        dummyStmt                                                                                                                   *)
(*      ) (pLit "WRITE" <|> pLit "READ") pUnit pFmt (zeroOrMore pTransfer) (pLit "DT_END")                                            *)
(*  let pIOOpen =                                                                                                                     *)
(*    pThen4 (fun _ _ _ _ -> dummyStmt)  (pLit "OPEN") pUnit pFile pStatus                                                            *)
(*  let pIO = pIORW <|> pIOOpen                                                                                                       *)
(*  let pCall =                                                                                                                       *)
(*    pThen5 (fun _ v _ es _ -> mkStmtOneInstr @$ Call (None, (Lval (Var (getVarinfo v),NoOffset)),es,locUnknown)                     *)
(*      ) (pLit "CALL") pAny open_ (zeroOrMore (pThen3 (fun _ e _ -> e) open_ pExp close)) close                                      *)
(*                                                                                                                                    *)
(*  let pContinue =                                                                                                                   *)
(*    pThen (fun n _ -> {dummyStmt with skind = Continue locUnknown}) pNumber (pLit "CONTINUE")                                       *)
(*  let pGoto =                                                                                                                       *)
(*    pThen (fun _ n -> {dummyStmt with skind = Goto(ref dummyStmt,locUnknown)}) (pLit "GOTO") pNumber                                *)
(*                                                                                                                                    *)
(*  let rec pStmt s =                                                                                                                 *)
(*    (pLoop <|> pAssign <|> pCall <|> pIO <|> pGoto) s                                                                               *)
(*  and pAssign =                                                                                                                     *)
(*    pThen3 (fun _ lv e -> mkStmtOneInstr (Set(lv,e,locUnknown))) (pLit "ASSIGN") pLval pExp                                         *)
(*  and pLoop s =                                                                                                                     *)
(*    (pThen7 (fun _ lv start end_ step s _ ->                                                                                        *)
(*      {dummyStmt with skind = Loop ({battrs=[];bstmts=[s]},locUnknown,None,None)}                                                   *)
(*      ) (pLit "DO") pLval pExp pExp pExp pStmt (pLit "END DO")) s                                                                   *)
(*                                                                                                                                    *)
(*  let pProc =                                                                                                                       *)
(*    pThen5 (fun ns pn c syms stmts -> GFun (                                                                                        *)
(*      {svar = {                                                                                                                     *)
(*        vname = pn;                                                                                                                 *)
(*        vtype = TFun(TVoid [],None,false,[]);                                                                                       *)
(*        vattr = [];                                                                                                                 *)
(*        vstorage = NoStorage;                                                                                                       *)
(*        vglob = true;                                                                                                               *)
(*        vinline = false;                                                                                                            *)
(*        vdecl = locUnknown;                                                                                                         *)
(*        vid = newVID ();                                                                                                            *)
(*        vaddrof = false;                                                                                                            *)
(*        vreferenced = false;                                                                                                        *)
(*        vdescr = Pretty.nil;                                                                                                        *)
(*        vdescrpure = true                                                                                                           *)
(*        };                                                                                                                          *)
(*      sformals = [];                                                                                                                *)
(*      slocals = syms;                                                                                                               *)
(*      smaxid = 0;                                                                                                                   *)
(*      sbody = {bstmts = stmts; battrs = []};                                                                                        *)
(*      smaxstmtid = None;                                                                                                            *)
(*      sallstmts =[]                                                                                                                 *)
(*       },locUnknown))                                                                                                               *)
(*        pNamespace pProcedureName pCommon (zeroOrMore pSymTree) (zeroOrMore pStmt)                                                  *)
(*  let pFile fname = pThen (fun procs _ -> {fileName = fname;                                                                        *)
(*    globals = procs;                                                                                                                *)
(*    globinit = None;                                                                                                                *)
(*    globinitcalled = false                                                                                                          *)
(*    }) (zeroOrMore pProc) pNothing                                                                                                  *)
(*  end                                                                                                                               *)
(*                                                                                                                                    *)
(*open Either                                                                                                                         *)
(*open LazyList                                                                                                                       *)
(*  let break f l = span (not*@f) l                                                                                                   *)
(*  let tokenize separators blanks quotes l =                                                                                         *)
(*    let isSeparator x = HashSet.mem (HashSet.of_list separators) x in                                                               *)
(*    let isBlank x = HashSet.mem (HashSet.of_list blanks) x in                                                                       *)
(*    let isQuote x = HashSet.mem (HashSet.of_list quotes) x in                                                                       *)
(*    let addPack pack s =                                                                                                            *)
(*      if pack==[] then s else fun () -> Cons(List.rev pack, s) in                                                                   *)
(*    let rec work pack s =                                                                                                           *)
(*          if null s then addPack pack empty else                                                                                    *)
(*            let x,xs = headTail s in                                                                                                *)
(*                if isQuote x then                                                                                                   *)
(*                  let xs',xs'' = break isQuote xs in                                                                                *)
(*                  addPack pack @$ addPack (['\'']@List.rev (to_list xs')@['\'']) @$                                                 *)
(*                    work [] @$ drop 1 xs''                                                                                          *)
(*                else if isSeparator x then                                                                                          *)
(*                  addPack pack @$ addPack [x] @$ fun () -> InC(work [] xs)                                                          *)
(*                else if isBlank x then                                                                                              *)
(*                  addPack pack @$ fun () -> InC(work [] xs)                                                                         *)
(*                else work (x::pack) xs                                                                                              *)
(*    in map (ExtString.of_list) @$ work [] l                                                                                         *)
(*open Parse                                                                                                                          *)
(*(*let () =                                                                                       *)                                 *)
(*(*  let l = tokenize [':';'(';')';'-'] [' ';'\t';'\n';'\r']                                      *)                                 *)
(*(*    (of_list @$ ExtString.to_list "Namespace: A-H: (REAL 8) I-N: (INTEGER 4) O-Z: (REAL 8)") in*)                                 *)
(*(*  print_endline @$ show_list id @$ LazyList.to_list l;                                         *)                                 *)
(*(*  print_endline @$                                                                             *)                                 *)
(*(*  match StateMonad.evalState pNamespace l with                                                 *)                                 *)
(*(*    | Left l -> sprintf "Left %s" @$ show_list id (take 1 l)                                   *)                                 *)
(*(*    | Right x -> sprintf "Right %s" @$ show_namespace x                                        *)                                 *)
(*(*                                                                                               *)                                 *)
(*let plainCilPrinter = new plainCilPrinterClass                                                                                      *)
(*let d_plainblock () x = plainCilPrinter#pBlock () x                                                                                 *)
(*let d_plainstmt () x = plainCilPrinter#pStmt () x                                                                                   *)
(*let d_plaininstr () x = plainCilPrinter#pInstr () x                                                                                 *)
(*let d_plainglob () x = new plainCilPrinterClass#pGlobal () x                                                                        *)
(*                                                                                                                                    *)
(*class lidoDumpStmtVisitor = object                                                                                                  *)
(*  inherit nopCilVisitor                                                                                                             *)
(*  method vglob gl =                                                                                                                 *)
(*    Errormsg.log "%a\n" d_plainglob gl;                                                                                             *)
(*    SkipChildren                                                                                                                    *)
(*end                                                                                                                                 *)
(*                                                                                                                                    *)
(*let dumpStmtsOfFile file = visitCilFile (new lidoDumpStmtVisitor) file                                                              *)
(*                                                                                                                                    *)
(*let parse fname =                                                                                                                   *)
(*  print_endline "[parse]";                                                                                                          *)
(*  let l = tokenize [':';'(';')';'-';'/';',';'='] [' ';'\t';'\n';'\r'] ['\'';'"']                                                    *)
(*    (of_list @$ ExtString.to_list @$ ExtUnix.readFile fname) in                                                                     *)
(*  match StateMonad.evalState (pFile fname) l with                                                                                   *)
(*    | Left l -> printf "Left %s" @$ show_list id (to_list l);flush stdout; failwith "parse"                                         *)
(*    | Right file ->                                                                                                                 *)
(*      dumpStmtsOfFile file;                                                                                                         *)
(*      print_endline "[parse done]";                                                                                                 *)
(*      file                                                                                                                          *)