(*|          let n = alignOf_int addedLocal.vtype / alignOf_int yy.vtype in
          let scale = integer n in
          let logscale = integer (log2 n) in
          let k = makeTempVar fdec j.vtype in
          let yyk = shift (var yy) (viExp k) in
          let yyj = shift (var yy) (viExp j) in
          let yy1 = addedLocal in
          let yy1k = shift (var addedLocal) (viExp k) in
          let blk =
            let body = mkStmtInstrs [assign t2vi yyk
                ; assignIndex yy (viExp k) (viExp tvi)
                ; assign tvi (viExp t2vi)] in
            mkForIncr k (shiftLeftExpr (shiftRightExpr (viExp j) logscale) logscale) (viExp j) one body in
          let blk' = [assign k (shiftRightExpr (viExp j) logscale)
            ; assign t2vi yyj
            ; assignIndex yy1 (viExp k) (borExpr (viExp tvi) (shiftLeftExpr yy1k scale))] in
          let incrJ = mkIncr PlusA (var j) one locUnknown in
          return @$ concat (replicate 7 @$ blk@[mkStmtOneInstr incrJ])
          @ blk @ mkStmtInstrs (blk' @ [incrJ])*)

(*|                                                                     
(** TODO: lookup def-use chain to see the initial value of index variable*)
let get_init = function Instr insts -> 
    (match (List.rev insts) with 
      Set(lv,exp,_)::tl ->
        Some (lv,exp,mkStmtInstrsMaybe (List.rev tl))
      |_->None
    ) |_->None
     
(** the upper bound is not strict*)   
let get_bound bstmts = match take 1 bstmts with
  [{skind=If(BinOp(op,Lval lv,exp,_),_,_,_)}] -> 
    (match op with 
      Le |Ge |Lt |Gt ->Some(lv,exp)
      |_-> None
    ) 
  |_->None
let get_stride bstmts = match take 1 (List.rev bstmts) with
  [{skind=Instr insts}] ->
    (match take 1 (List.rev insts) with 
      [Set((Var vi,NoOffset) as lv,BinOp(PlusA,Lval (Var vi2,NoOffset),stride,_),_)] -> 
        if vi.vid = vi2.vid then Some (lv,stride) else None
    |_->None
    ) |_->None  
let get_body bstmts = (** remove the first 'break'.*)
  match bstmts with If(BinOp,_,_,_)::exceptBreak -> begin
    (*! match List.rev exceptBreak with {skind=Instr il}::exceptBreakTail -> begin
      match List.rev il with inc::ilTail ->
        Some (List.rev (mkStmtInstrs ilTail@exceptBreakTail))
      |_ -> None 
    end 
      |_ -> None
    end  *)
    Some exceptBreak
  |_ -> None              
let rec get_loop_struct (s1,s2) =
    match s1.skind,s2.skind with Instr insts,Loop({bstmts=_::_} as blk,_,_,_) -> begin
        match get_init s1.skind,get_bound blk.bstmts,get_stride blk.bstmts,get_body blk.bstmts
        with Some(lv1,init,tl),Some(lv2,bound),Some(lv3,stride),Some body ->
            guard (equalLval lv1 lv2 && equalLval lv2 lv3) >>
                (match lv1 with Var vi,_ -> 
                    let res = {vi=vi;init=init;bound=bound;stride=stride;body=body;} in
                    show_loop_struct res;
                    Some res
                |_->None)
    (*|None,_,_ -> (match s2.skind with Loop _-> E.log "init stmt %a\n" d_stmt s1|_-> ());None*)
        |_->None
    end
    |_-> None
*)

(*let transRotateByteArrayLoop fdec tvi yy j ls =                                            *)
(*  let findAllInstr l =                                                                     *)
(*    let rec loop stk = function                                                            *)
(*      | [] -> Some (rev stk)                                                               *)
(*      | { skind = Instr is }:: xs -> loop (is@stk) xs                                      *)
(*      | _ -> None in                                                                       *)
(*    loop [] l in                                                                           *)
(*(*  alignArray fdec yy.vid ulonglongType >>= fun addedLocal ->*)                           *)
(*  findAllInstr ls.body >>= function                                                        *)
(*      | [ _                                                                                *)
(*      ; Set ((Var vi, NoOffset), BinOp(PlusA, Lval(Var vi', NoOffset), e, _), _)           *)
(*      ; Set ((Var t2vi, NoOffset), Lval (Var tvi, NoOffset), _)                            *)
(*      ; Set ((Var tvi', NoOffset), Lval (Var yy', NoOffset), _)                            *)
(*      ; Set (                                                                              *)
(*      (Mem(BinOp(PlusPI, Lval(Var yy'', NoOffset), Lval(Var idx, NoOffset), _)), NoOffset),*)
(*      Lval (Var t2vi', NoOffset), _)                                                       *)
(*      ]                                                                                    *)
(*      when allEquals [vi.vid; vi'.vid; j.vid]                                              *)
(*      && equalExp e one                                                                    *)
(*      && idx.vid = j.vid                                                                   *)
(*      && allEquals [t2vi.vid; t2vi.vid]                                                    *)
(*      && allEquals [tvi.vid; tvi'.vid]                                                     *)
(*      && allEquals [yy.vid; yy'.vid; yy''.vid]                                             *)
(*      && isShift yy (viExp j) e ->                                                         *)
(*                                                                                           *)
(*          return @$ [mkStmtOneInstr                                                        *)
(*                      @$ Call(None,viExp rotr_till,[viExp yy;ls.bound],locUnknown)]        *)
(*      | _ -> None                                                                          *)

(*let transRotateByteArray fdec =                                                                          *)
(*  let findAllInstr l =                                                                                   *)
(*    let rec loop stk = function                                                                          *)
(*      | [] -> return (rev stk)                                                                           *)
(*      | { skind = Instr is }:: xs -> loop (is@stk) xs                                                    *)
(*      | _ -> mzero in                                                                                    *)
(*    loop [] l in                                                                                         *)
(*  function                                                                                               *)
(*(*| match with below, also assure yy is char array.*)                                                    *)
(*(*|       j = 0;                                                                                         *)
(*      tmp = yy[j];                                                                                       *)
(*      while ( ll_i != tmp ) {                                                                            *)
(*         j++;                                                                                            *)
(*         tmp2 = tmp;                                                                                     *)
(*         tmp = yy[j];                                                                                    *)
(*         yy[j] = tmp2;                                                                                   *)
(*      };                                                                                                 *)
(*      yy[0] = tmp; *)                                                                                    *)
(*  | [{ skind = Instr is }                                                                                *)
(*    ;{ skind = Loop ({bstmts = {skind = If (cmp,_,_,_)}:: blkTail},_,_,_) }                              *)
(*    ;{ skind = Instr is3 }] ->                                                                           *)
(*    findAllInstr blkTail >>= fun insts ->                                                                *)
(*          (match take 2 (rev is), tl insts, take 1 is3 with                                              *)
(*            | [Set((Var j,NoOffset), e, _)                                                               *)
(*              ;Set((Var tmp,NoOffset), yyj, _)]                                                          *)
(*              ,[Set ((Var vi, NoOffset), BinOp(PlusA, Lval(Var vi', NoOffset), e, _), _)                 *)
(*                    ; Set ((Var t2vi, NoOffset), Lval (Var tvi, NoOffset), _)                                  *)
(*                    ; Set ((Var tvi', NoOffset), Lval (Var yy', NoOffset), _)                                  *)
(*                    ; Set (                                                                                    *)
(*                    (Mem(BinOp(PlusPI, Lval(Var yy'', NoOffset), Lval(Var idx, NoOffset), _)), NoOffset),      *)
(*                    Lval (Var t2vi', NoOffset), _)                                                             *)
(*                    ]                                                                                          *)
(*              ,[Set((Mem(BinOp(PlusPI, Lval(Var yy, NoOffset),idx,_)), NoOffset)                         *)
(*                  , Lval (Var tmp',NoOffset), _)] when                                                   *)
(*                    ls.vi.vid = j.vid                                                                    *)
(*                    && equalExp e zero                                                                   *)
(*                    && equalExp idx zero                                                                 *)
(*                    && tmp.vid = tmp'.vid                                                                *)
(*                    && equalExp yyj (shift (var yy) (viExp j))                                           *)
(*                    && allEquals [vi.vid; vi'.vid; j.vid]                                                *)
(*                                && equalExp e one                                                                    *)
(*                                && idx.vid = j.vid                                                                   *)
(*                                && allEquals [t2vi.vid; t2vi.vid]                                                    *)
(*                                && allEquals [tvi.vid; tvi'.vid]                                                     *)
(*                                && allEquals [yy.vid; yy'.vid; yy''.vid]                                             *)
(*                                && isShift yy (viExp j) e                                                            *)
(*                    ->                                                                                   *)
(*(*                      transRotateByteArrayLoop fdec tmp yy j ls*)                                      *)
(*                        return @$ [mkStmtOneInstr                                                        *)
(*                            @$ Call(None,viExp rotr_till,[viExp yy;ls.bound],locUnknown)]                *)
(*            | _ -> mzero                                                                                 *)
(*          )                                                                                              *)
(*  | [{ skind = Loop _ } as s1;{ skind = Loop _ } as s2;{ skind = Instr is3 }] ->                         *)
(*    getLoopStructOneStmt s1 >>= fun ls ->                                                                *)
(*      getLoopStructOneStmt s2 >>= fun ls2 ->                                                             *)
(*        guard (ls.vi.vid = ls2.vi.vid) >> (* same index *)                                               *)
(*        firstInstr*@ hd @$ roll (length ls.body) ls.body >>= fun instr ->                                *)
(*        firstInstr (hd ls2.body) >>= fun instr' ->                                                       *)
(*        guard (equalInstr instr instr') >>                                                               *)
(*        lhs instr >>= fun lv ->                                                                          *)
(*        chopArray (Lval lv) >>= fun (yy,_) -> begin                                                      *)
(*          match hd is3 with                                                                              *)
(*            | Set ((Mem(BinOp(PlusPI, Lval(Var yy', NoOffset),idx,_)), NoOffset),tmp,_)                  *)
(*                when equalExp idx zero && yy'.vid = yy.vid ->                                            *)
(*                  return @$ [mkStmtOneInstr                                                              *)
(*                      @$ Call(None,viExp shiftr,[viExp yy;viExp ls.vi;tmp],locUnknown)]                  *)
(*            | _ -> mzero                                                                                 *)
(*        end                                                                                              *)
(*  | _ -> None                                                                                            *)
  
(*                                                                           *)
(*class instructionStream                                                    *)
(*    num                                                                    *)
(*    (transform: fundec -> instr list-> stmt list option)                   *)
(*  = object(self) inherit nopCilVisitor                                     *)
(*    val currentFundec = ref None                                           *)
(*    method vglob = function                                                *)
(*      GFun (fundec, l) -> currentFundec := Some fundec;DoChildren          *)
(*    | _ -> SkipChildren                                                    *)
(*                                                                           *)
(*  method vstmt s =                                                         *)
(*    let changed = ref false in                                             *)
(*    match s.skind with Instr insts -> begin                                *)
(*    let rec proc acc stack = function                                      *)
(*      [] -> List.rev acc                                                   *)
(*      | post ->                                                            *)
(*        match transform (fromSome !currentFundec) (take num post) with     *)
(*          Some res ->                                                      *)
(*            changed:=true;                                                 *)
(*            proc (res@mkStmtInstrs (List.rev stack)@acc) [] (drop num post)*)
(*      | None -> proc acc (List.hd post::stack) (List.tl post)              *)
(*    in                                                                     *)
(*    let insts' = proc [] [] insts in                                       *)
(*    if !changed then ChangeTo(mkBlockStmt insts') else DoChildren          *)
(*    end                                                                    *)
(*    |_->DoChildren                                                         *)
(*end                                                                        *)

(*class statementStream                                                                            *)
(*    num                                                                                          *)
(*    (transform: fundec -> stmt list-> stmt list option)                                          *)
(*  = object(self) inherit nopCilVisitor                                                           *)
(*    val currentFundec = ref None                                                                 *)
(*    method vglob = function                                                                      *)
(*      GFun (fundec, l) -> currentFundec := Some fundec;DoChildren                                *)
(*    | _ -> SkipChildren                                                                          *)
(*    method vblock blk =                                                                          *)
(*        let changed = ref false in                                                               *)
(*        let rec loop stk = function                                                              *)
(*          [] -> List.rev stk                                                                     *)
(*        | (x::xs) as l -> begin                                                                  *)
(*            match transform (fromSome !currentFundec) (take num l) with                          *)
(*                Some x' -> changed:=true;loop (x'@stk) (drop num l)                              *)
(*                | None -> loop (x::stk) xs                                                       *)
(*        end in                                                                                   *)
(*        let stmts = loop [] blk.bstmts in                                                        *)
(*        if !changed then ChangeTo {blk with bstmts = stmts} else DoChildren                      *)
(*end                                                                                              *)
(*                                                                                       *)

(*let iterLoops f file =                                  *)
(*  visitCilFileSameGlobals                               *)
(*    (new statementStream 2 (fun fdec ->                 *)
(*      function                                          *)
(*        | [s;s2] -> fmap (f fdec) (getLoopStruct (s,s2))*)
(*        | _ -> None                                     *)
(*      )) file                                           *)        

(*(** Make a local variable and add it to front of a function *)*)
(*let makeLocalVarAtFront fdec ?(insert = true) name typ =      *)
(*  let vi = makeLocal fdec name typ in                         *)
(*  if insert then fdec.slocals <- vi::fdec.slocals;            *)
(*  vi                                                          *)

(*let kindTable : (int,kind option) Hashtbl.t = Hashtbl.create 37              *)
(*let addToTable k v kt =                                                      *)
(*  Hashtbl.replace kt k @$ maybe v (maybefind Hashtbl.find kt k >>= fun v' -> *)
(*      guard (v=v') >> return v)                                              *)
(*class abVisitor = object                                                     *)
(*    inherit nopCilVisitor                                                    *)
(*  method voffs = function                                                    *)
(*    | Index(e,_) ->                                                          *)
(*      ignore @$ unViExp e >>= fun vi ->                                      *)
(*        addToTable vi.vid KIndex kindTable;                                  *)
(*      DoChildren                                                             *)
(*    | _ -> DoChildren                                                        *)
(*end                                                                          *)
(*exception IsIndex                                                            *)
(*class isIndexVisitor vi = object                                             *)
(*  inherit nopCilVisitor                                                      *)
(*  method voffs = function                                                    *)
(*    | Index(e,_) -> if (exp_has_vi vi) then raise IsIndex else DoChildren    *)
(*    | _ -> DoChildren                                                        *)
(*  method vexpr = function                                                    *)
(*    | BinOp(PlusPI,Lval(Var _,_),e,_) ->                                     *)
(*      if (exp_has_vi vi) then raise IsIndex else DoChildren                  *)
(*    | _ -> DoChildren                                                        *)
(*end                                                                          *)
(*let foundIndexProofInFile vi file =                                          *)
(*  try visitCilFile (new isIndexVisitor vi) file;false                        *)
(*  with IsIndex ->true                                                        *)
(*class transformUnionToStructVisitor = object                                 *)
(*  inherit nopCilVisitor                                                      *)
(*                                                                             *)
(*end                                                                          *)

(*(* being not ambitious, we just find out KIndex by looking at indices, and trust the*)*)
(*(* assume that KPointer has pointer type*)                                            *)
(*class collectIndexVisitor indicesTable = object                                       *)
(*  inherit nopCilVisitor                                                               *)
(*  method voffs = function                                                             *)
(*    | Index(e,_) ->                                                                   *)
(*      ignore (unViExp e >>= fun vi ->                                                 *)
(*        return @$ addRefList vi.vid indicesTable);                                    *)
(*      DoChildren                                                                      *)
(*    | _ -> SkipChildren                                                               *)
(*end                                                                                   *)
(*let collectIndex file =                                                               *)
(*  let l = ref [] in                                                                   *)
(*  visitCilFile (new collectIndexVisitor l) file;                                      *)
(*  !l                                                                                  *)
(*class unionToStructVisitor indexVids = object                                         *)
(*    inherit nopCilVisitor                                                             *)
(*    method vtype ty = match ty with                                                   *)
(*      | TComp (ci,_) ->                                                               *)
(*        if not ci.cstruct                                                             *)
(*            && hasNoDupesBy equalTyp (map (fun fi -> fi.ftype) ci.cfields) then begin *)
(*                foreach ci.cfields @$ fun fi ->                                       *)
(*                  E.log "%s:%a\n" fi.fname d_plaintype fi.ftype;                      *)
(*                ci.cstruct <- true                                                    *)
(*            end;                                                                      *)
(*        DoChildren                                                                    *)
(*      | _ -> DoChildren                                                               *)
(*(*    method vglob gl = match gl with*)                                               *)
(*(*      | GCompTagDecl (ci,_)        *)                                               *)
(*(*      | GCompTag (ci,_) ->         *)                                               *)
(*(*        ci.cstruct <- false;       *)                                               *)
(*(*        DoChildren                 *)                                               *)
(*(*      | _ -> SkipChildren          *)                                               *)
(*end                                                                                   *)
(*let trans file =                                                                      *)
(*  let indexVids = collectIndex file in                                                *)
(*  visitCilFile (new unionToStructVisitor indexVids) file;                             *)
(*  file                                                                                *)
(*let mergeEq e e' = match e,e' with         *)
(*  | Val(s,i),Val(s',i') ->                 *)
(*    if s <> s' then return [e;e']          *)
(*    if i=i' then return Val(s,i) else mzero*)
(*  |                                        *)

(*(**                                                                                    *)
(*to integer values. [Index i] refers to those that can serve as                         *)
(*array index. [Pointer i] refers to memory addresses. By type safety, a variable will   *)
(*have fixed kind, and a value read by wrong kind will yield garbage,                    *)
(*which is not allowed under [our]type safety assumption. As a consequence, if a union is*)
(*found to contain two fields of different kinds, then it will be safe to transform the  *)
(*union into a structure.*)                                                              *)
(*type kind =                                                                            *)
(*  | KIndex                                                                             *)
(*  | KPointer                                                                           *)
(*let indexUref = Uref.uref KIndex                                                       *)
(*let pointerUref = Uref.uref KPointer                                                   *)
(*let kindTable : (int, kind uref) Hashtbl.t = Hashtbl.create 32767                      *)
(*                                                                                       *)
(*(* being not ambitious, we just find out KIndex by looking at indices, and *)          *)
(*(* trust the assume that KPointer has pointer type                         *)          *)
(*class collectIndexVisitor kindTable = object                                           *)
(*  inherit nopCilVisitor                                                                *)
(*  method voffs = function                                                              *)
(*    | Field(fi, _) ->                                                                  *)
(*        compFullName fi.fcomp ^"."^fi.fname                                            *)
(*    | Index(e, _) ->                                                                   *)
(*        ignore (unViExp e >>= fun vi ->                                                *)
(*                maybefind Hashtbl.find kindTable vi.vid >>= fun kuref ->               *)
(*                    return @$ Uref.union (kuref, indexUref));                          *)
(*        DoChildren                                                                     *)
(*    | _ -> SkipChildren                                                                *)
(*end                                                                                    *)
(*(* let collectIndex file = *)                                                          *)
(*class unionToStructVisitor indexVids = object                                          *)
(*  inherit nopCilVisitor                                                                *)
(*  method vtype ty = match ty with                                                      *)
(*    | TComp (ci, _) ->                                                                 *)
(*        if not ci.cstruct                                                              *)
(*        && hasNoDupesBy equalTyp (map (fun fi -> fi.ftype) ci.cfields) then begin      *)
(*          foreach ci.cfields @$ fun fi ->                                              *)
(*              E.log "%s:%a\n" fi.fname d_plaintype fi.ftype;                           *)
(*              ci.cstruct <- true                                                       *)
(*        end;                                                                           *)
(*        DoChildren                                                                     *)
(*    | _ -> DoChildren                                                                  *)
(*  (* method vglob gl = match gl with | GCompTagDecl (ci,_) | GCompTag (ci,_) *)        *)
(*  (* -> ci.cstruct <- false; DoChildren | _ -> SkipChildren                  *)        *)
(*end                                                                                    *)
(*let trans file = file |> visitCilFile (new collectIndexVisitor kindTable)              *)
(*  |> visitCilFile (new unionToStructVisitor indexVids)                                 *)

(*class lidoPlainCilPrinterClass = object (self)                                                              *)
(*  inherit plainCilPrinterClass as super                                                                     *)
(*  method pInst () = function                                                                                *)
(*    Set(lv,e,_) -> dprintf "@[%a <- @?%a@]" d_plainlval lv d_plainexp e                                     *)
(*    | Call(lvo,e,es,_) -> dprintf "@[%a@]@?@[%a(%a)@]"                                                      *)
(*      (fun _ -> maybe nil (fun lv -> d_plainlval () lv ++ text " = ")) lvo                                  *)
(*      d_plainexp e                                                                                          *)
(*      (docList ~sep:(chr ',' ++ break) (fun e -> d_plainexp () e)) es                                       *)
(*    | Asm _ -> dprintf "asm text"                                                                           *)
(*  method pStmtkind () = function                                                                            *)
(*    Instr insts -> dprintf "Instr(@[%a@])"                                                                  *)
(*        (docList ~sep:(break) (fun inst -> self#pInst () inst)) insts                                       *)
(*    | Return(eo,_) -> dprintf "Return(@[%a@])"                                                              *)
(*      (fun _ -> maybe nil (fun e -> d_plainexp () e)) eo                                                    *)
(*    | Goto(rstmt,_) -> dprintf "Goto(@[%a@])" self#pStmt !rstmt                                             *)
(*    | Break loc -> dprintf "Break(@[%a@])" self#pLocation loc                                               *)
(*    | Continue loc -> dprintf "Continue(@[%a@])" self#pLocation loc                                         *)
(*    | If (e,tb,fb,loc) -> dprintf "If (@[%a@]) (@[%a@]) (@[%a@])" d_plainexp e self#pBlock tb self#pBlock fb*)
(*    | Loop (blk,loc,so,so2) -> dprintf "Loop (@[%a@])" self#pBlock blk                                      *)
(*    | Block blk -> dprintf "Block (@[%a@])" self#pBlock blk                                                 *)
(*    | _ -> failwith "lidoPlainCilPrinterClass.pStmtkind"                                                    *)
(*                                                                                                            *)
(*  method pLocation () loc = dprintf "Loc(line:%d,file:%s,byte%d)"                                           *)
(*    loc.line loc.file loc.byte                                                                              *)
(*  method pBlock () blk = dprintf "Block(@[%a@])"                                                            *)
(*    (docList ~sep:(chr ',' ++ break) (fun s -> self#pStmt () s)) blk.bstmts                                 *)
(*(*  method pGlobal () = function                                    *)                                      *)
(*(*    | GType(tyi,loc) -> dprintf "Break(@[%a@])" self#pLocation loc*)                                      *)
(*end                                                                                                         *)
(*                                                                                                            *)
(*let lidoPlainCilPrinter = new lidoPlainCilPrinterClass                                                      *)
(*let d_plainblock () x = lidoPlainCilPrinter#pBlock () x                                                     *)
(*let d_plainstmtkind () x = lidoPlainCilPrinter#pStmtkind () x                                               *)
(*let d_plainstmt () x = lidoPlainCilPrinter#pStmt () x                                                       *)
(*let d_plaininst () x = lidoPlainCilPrinter#pInst () x                                                       *)

(*let rec chopPointer a : array_struct option =                                         *)
(*  let rec loop stk = function                                                         *)
(*    | Lval (Mem(BinOp(IndexPI,Lval(Var vi,NoOffset),i,_)),NoOffset) -> return (vi,stk)*)
(*    | Lval (Mem(BinOp(IndexPI,p,i,_)),NoOffset) -> loop (i::stk) p                    *)
(*    | _ -> mzero in                                                                   *)
(*  loop [] a >>= fun (vi,stk) ->                                                       *)
(*    return (vi,stk)                                                                   *)
(*                                                                                      *)
(*(* ( *p)[0][1] will have ( *p,[zero;one]) here *)                                     *)
(*let rec chopArrayIndex a =                                                            *)
(*  let rec loop stk = function                                                         *)
(*    | NoOffset -> return @$ rev stk                                                   *)
(*    | Index(e,off) -> loop (e::stk) off                                               *)
(*    | _ -> mzero in                                                                   *)
(*  loop [] a                                                                           *)
  
(*let rec chopLval lv = match lv with             *)
(*  | Mem(BinOp(IndexPI,Lval lv,i,_)),NoOffset -> *)

(*let chopIndices acc = function*)
(*  | NoOffset -> rev acc       *)
(*  |                           *)

(*type core = Core of varinfo * fieldinfo list*)
(*(core * exp list                            *)
(*and type index                              *)
(* don't handle struct for now*)
(*let rec transExp = function                                   *)
(*(*  | Lval (lh,Field(fi,off)) -> (lh,Field(fi,NoOffset)),off*)*)
(*  | Lval (lh,off) -> (lh,NoOffset),off                        *)
(*  | StartOf                                                   *)

(*let rec derefTill f e =                                  *)
(*  untill isNone (match typeOf e with TComp _ -> None |   *)
(*  match f e with                                         *)
(*    | None -> derefTill f (f e)                          *)
(*    | Some e' -> e'                                      *)
(*let rec unChopLval (vi,es) = unChopLhost (vi,es),NoOffset*)
(*(*  match vi.vtype with                              *)  *)
(*(*  | TArray _ -> unChopLhost (vi,[]),unChopOffset es*)  *)
(*(*  | TPtr _ -> unChopLhost (vi,es),NoOffset         *)  *)
(*and unChopExp (vi,l) =                                   *)
(*  let off = unChopOffset l in                            *)
(*  match off with                                         *)
(*    | Field _ -> begin match vi.vtype with               *)
(*                                                         *)
(*  mkAddrOrStartOf (Var vi, )                             *)
(*(*                                           *)          *)
(*(*  match l with                             *)          *)
(*(*  | [] -> mkAddrOrStartOf (Var vi,NoOffset)*)          *)
(*(*  | AIndex e::es ->                        *)          *)
(*(*    let e' = unChopExp (vi,es) in          *)          *)
(*(*    BinOp(PlusPI,e',e,typeOf e')           *)          *)
(*(*  | AField fi::es ->                       *)          *)
(*(*    unChopOffset                           *)          *)
(*(*    unChopLhost (vi,es),Field fi           *)          *)
(*and unChopLhost (vi,l) = match l with                    *)
(*  | [] -> Var vi                                         *)
(*  | _ -> Mem (unChopExp (vi,l))                          *)
(*and unChopOffset l = match l with                        *)
(*  | AField fi ::xs -> Field(fi,unChopOffset xs)          *)
(*  | AIndex e ::xs -> Index(e,unChopOffset xs)            *)
(*  | [] -> NoOffset                                       *)

(*let unChopLval (lv,l) = match l with                                          *)
(*  | [] -> lv                                                                  *)
(*  | AIndex e:: xs -> begin match vi.vtype with                                *)
(*    | TArray _ -> unChopLval ((Var vi,Index (e,NoOffset)),xs)                 *)
(*    | TPtr _ -> unChopLval (derefTillArray (viExp vi),Index (e,NoOffset)),xs) *)
(*    | _ -> failwith "unChopLvalVi"                                            *)
(*    end                                                                       *)
(*  | AField fi:: xs -> begin match vi.vtype with                               *)
(*    | TComp _ -> unChopLval ((Var vi,Field (fi,NoOffset)),xs)                 *)
(*    | TPtr _ -> unChopLval ((derefTillComp (viExp vi),Field (fi,NoOffset)),xs)*)
(*    | _ -> failwith "unChopLvalVi"                                            *)
(*    end                                                                       *)

(*let lhostToExp lh l = match l with                   *)
(*  | [] -> Lval (lh,NoOffset)                         *)
(*  | AIndex e :: xs -> begin match typeOfLval lv with *)
(*    | TArray _ -> lvalToExp (lh,Index(e,NoOffset)) xs*)
(*    | _ -> failwith "lhostToLval"                    *)
(*let lvalToExp lv l= match l with                     *)
(*  | [] -> Lval lv                                    *)
(*  | AIndex e :: xs ->                                *)
(*let unChopV (vi,l) = match l with                    *)
(*  | [] -> Var vi,NoOffset                            *)
(*  | AIndex e :: xs -> begin match vi.vtype with      *)
(*    | TArray _ -> Var vi,Index(e,unChopOffset xs)    *)
(*  | AField fi ::xs -> begin match vi.vtype with      *)
(*    | TPtr _ -> unChopLvalExp (Mem (viExp vi),l)     *)
(*    | TComp _ -> Var vi,Field(fi,unChopOffset xs)    *)
(*    | _ -> failwith "unChopLvalVi"                   *)
(*    end                                              *)
(*and unChopLvalExp (e,l) = match l with               *)
(*  | [] -> Mem e,NoOffset                             *)
(*  | AIndex e' :: xs ->                               *)

(*let derefTillTyp e ty =                              *)
(*  until (fun e -> equalTyp ty @$ typeOf e) derefExp e*)

(*  method vlval lv =                                                     *)
(*    chopLval lv >>= fun (vi,l) ->                                       *)
(*      addRefList  kindTable                                             *)
(*  method voffs = function                                               *)
(*    | Index(e, _) ->                                                    *)
(*        ignore (unViExp e >>= fun vi ->                                 *)
(*                maybefind Hashtbl.find kindTable vi.vid >>= fun kuref ->*)
(*                    return @$ Uref.union (kuref, indexUref));           *)
(*        DoChildren                                                      *)
(*    | _ -> SkipChildren                                                 *)

(*let rec unifyAccesses l ac' = match ac,ac' with*)
(*  | AField fi,AField fi' ->                    *)
(*let rec rankExp n = function            *)
(*  | Lval(lh,off) -> begin match off with*)
(*    | NoOffset -> rankLhost n lh        *)
(*    | Field _ -> StateMonad.return ()   *)
(*    | Index (e,off') ->                 *)
(*and rankLhost n = function              *)
(*  | Var vi -> modify (cons Eq(vi.vid,n))*)
(*  | Mem e -> rankExp (n+1) e            *)
(*  let rec loop vi l vi' l' = match l,l' with     *)
(*    | [],_ ->                                    *)
(*    | _,[] ->                                    *)
(*    | AIndex e::xs ,AIndex e'::xs' ->            *)
(*      markExp e 0;                               *)
(*      markExp e' 0;                              *)
(*      loop vi vi' xs xs'                         *)
(*    | AField fi::xs,AIndex e'::xs' ->            *)
(*      markExp e' 0;                              *)
(*      addRefList (Equal(EField fi,0)) rankEqs    *)
(*  | AIndex e::xs -> begin match unrollType @$ typeOfLval (lh,off) with *)
(*(*    | TPtr _ ->                                                   *) *)
(*(*      let addr = mkAddrOrStartOf(lh,off) in                       *) *)
(*(*      unChopLhost ((Mem(BinOp(PlusPI,addr,e,typeOf addr)))) off xs*) *)
(*    | TArray _ -> unChopLhost lh (addOffset (Index(e,NoOffset)) off) xs*)
(*    | _ -> failwith "unChopLhost"                                      *)
(*    end                                                                *)

(*  let derefTillArray e =                                                                   *)
(*    until (fun e -> match typeOfLhost e with TArray _ -> true | _ -> false) derefLhost e in*)
(*    let derefTillComp e =                                                                   *)
(*      until (fun e -> match typeOfLhost e with TComp _ -> true | _ -> false) derefLhost e in*)
(*      let e' = Lval (lh,off) in             *)
(*      let addr = match typeOf e' with       *)
(*        | TPtr _ | TArray _ -> e'           *)
(*        | _ -> mkAddrOrStartOf (lh,off) in  *)
(*  | AAddress ::AMem :: xs -> unChopLhost lh off xs*)
(*  | AAddress ::xs -> unChopLhost (Mem (mkAddrOrStartOf (lh,off))) NoOffset xs*)
(*    | TPtr _ -> unChopLhost (derefTillComp (Mem(Lval(lh,off)))) (Field(fi,NoOffset)) xs*)

(*let markIndex = ignore *@ function            *)
(*  | AIndex e ->                               *)
(*    unViExp e >>= fun vi ->                   *)
(*      return @$ addRefList (Val(vi,0)) rankEqs*)
(*  | AField fi ->                              *)
(*    return ()                                 *)
(*let isAIndex = function*)
(*  | AIndex _ -> true   *)
(*  | _ -> false         *)
(*let rec markViBy f n vi =                                         *)
(*  f n (EVarinfo vi)                                               *)
(*and markBy f n (vi,l)=                                            *)
(*  markLBy f n l;                                                  *)
(*  if all isAIndex l then markViBy f (n+length l) vi else          *)
(*    let l' = dropWhile isAIndex (rev l) in                        *)
(*    match hd l' with                                              *)
(*      | AField fi ->                                              *)
(*        f (n+length (tl l')) (EField fi)                          *)
(*      | _ -> failwith "mark"                                      *)
(*and markExpBy f n e =                                             *)
(*  ignore (chopExp e >>= fun (vi,l) -> markBy f n (vi,l);return ())*)
(*and markLBy f n l =                                               *)
(*  foreach (l) (function                                           *)
(*    | AIndex e -> markExpBy f n e                                 *)
(*    | _ -> ())                                                    *)

(*                                                    *)
(*  if all isAIndex l then (EVarinfo vi,length l) else*)
(*    let l' = dropWhile isAIndex (rev l) in          *)
(*    match hd l' with                                *)
(*      | AField fi ->                                *)
(*        EField fi, length (tl l')                   *)
(*      | _ -> failwith "prune"                       *)
(*        (* TODO: here we trust type, replace it by rank we found *)        *)
(*(*        && hasNoDupesBy equalTyp (map (fun fi -> fi.ftype) ci.cfields) *)*)
(*        && (match map (fun fi -> fi.ftype) ci.cfields with                 *)
(*          | [TPtr _;TInt _]                                                *)
(*          | [TInt _;TPtr _] -> true                                        *)
(*          | _ -> false                                                     *)
(*        )                                                                  *)

(*| let getIndexVariable : stmtkind -> varinfo option = function
Loop (blk, _, _, _) -> begin
match blk.bstmts with
s:: _ -> begin
match s.skind with
(* Instr [Set ((Var vi,NoOffset),_,_)] -> Some vi *)
If ((BinOp(_, Lval(Var vi, NoOffset), _, _)), _, _, _) -> Some vi
| _ -> if !debug then E.log "stmt %a\n" d_stmt s; None
end
| _ -> None
end
| _ -> None *)
(*| class simpleArrayFinder vs = object
inherit nopCilVisitor
method vstmt s =
if VS.is_empty (VS.inter !vs (snd (UD.computeDeepUseDefStmtKind s.skind))) then SkipChildren else
match s.skind with
Loop (blk, _, _, _) -> begin
match get_loop_struct blk.bstmts with
Some { init = init; bound = bound;} -> ()
| None -> vs := VS.remove vis !vs
end; DoChildren
end *)

(*| let checkSimpleArray idx = function {skind = Instr il} ->
let inspect = function Set ((Mem (BinOp(IndexPI, _, _, _) as e), NoOffset), e2, _) ->

| _ -> ()
List.iter () il
| _ -> () *) 

(*open TLattice                                                                                 *)
(*let equiv i i' = match i, i' with                                                             *)
(*  | Set(lv, e, _), Set(lv', e', _) -> make [lv; lv']                                          *)
(*  | Call(lvo, e, es, _), Call(lvo', e', es', _) -> begin                                      *)
(*    match lvo, lvo' with                                                                      *)
(*      | Some lv, Some lv' -> make [lv; lv']                                                   *)
(*      | None, None -> Top                                                                     *)
(*      | _ -> Bottom                                                                           *)
(*    end                                                                                       *)
(*  | _ -> Bottom                                                                               *)
(*                                                                                              *)
(*open ExtList                                                                                  *)
(*let equivList = function                                                                      *)
(*  | [] -> Top                                                                                 *)
(*  | x:: xs ->                                                                                 *)
(*    foldl (meet ~eq: (fun _ _ -> true) ~select: (fun (e, e') -> e@e')) Top @$ map (equiv x) xs*)

(* let groupOfList = function | *)

(*module UD = struct                                                                       *)
(*  let considerVariableUse = ref (fun _ -> true)                                          *)
(*  let considerVariableDef = ref (fun _ -> true)                                          *)
(*  let considerVariableAddrOfAsUse = ref (fun _ -> true)                                  *)
(*  let onlyNoOffsetsAreDefs = ref false                                                   *)
(*  let ignoreSizeof = ref false                                                           *)
(*  let extraUsesOfExpr = ref (fun _ -> VS.empty)                                          *)
(*  let getUseDefFunctionRef: (exp -> exp list -> VS.t * VS.t * exp list) ref =            *)
(*    ref (fun func args -> (VS.empty, VS.empty, args))                                    *)
(*                                                                                         *)
(*  class useDefVisitorClass varUsed varDefs : cilVisitor = object (self)                  *)
(*    inherit nopCilVisitor                                                                *)
(*                                                                                         *)
(*    (** this will be invoked on variable definitions only because we intercept           *)
(*    * all uses of variables in expressions ! *)                                          *)
(*    method vvrbl (v: varinfo) =                                                          *)
(*      if (!considerVariableDef) v &&                                                     *)
(*      not(!onlyNoOffsetsAreDefs) then                                                    *)
(*        varDefs := VS.add v !varDefs;                                                    *)
(*      SkipChildren                                                                       *)
(*                                                                                         *)
(*    (** If onlyNoOffsetsAreDefs is true, then we need to see the                         *)
(*    * varinfo in an lval along with the offset. Otherwise just                           *)
(*    * DoChildren *)                                                                      *)
(*    method vlval (l: lval) =                                                             *)
(*      if !onlyNoOffsetsAreDefs then                                                      *)
(*        match l with                                                                     *)
(*        | (Var vi, NoOffset) ->                                                          *)
(*            if (!considerVariableDef) vi then                                            *)
(*              varDefs := VS.add vi !varDefs;                                             *)
(*            SkipChildren                                                                 *)
(*        | (Var vi, Field(fi, NoOffset)) when not fi.fcomp.cstruct ->                     *)
(*        (* If we are writing to a union field, treat that the same as a write to a *)    *)
(*        (* union.                                                                  *)    *)
(*            if (!considerVariableDef) vi then                                            *)
(*              varDefs := VS.add vi !varDefs;                                             *)
(*            SkipChildren                                                                 *)
(*        | (Mem (BinOp(IndexPI, Lval(Var vi, NoOffset), _, _)), _) ->                     *)
(*            varDefs := VS.add vi !varDefs;                                               *)
(*            DoChildren                                                                   *)
(*        | _ -> DoChildren                                                                *)
(*      else DoChildren                                                                    *)
(*                                                                                         *)
(*    method vexpr (e: exp) =                                                              *)
(*      let extra = (!extraUsesOfExpr) e in                                                *)
(*      if not (VS.is_empty extra) then                                                    *)
(*        varUsed := VS.union extra !varUsed;                                              *)
(*      match e with                                                                       *)
(*        Lval (Var v, off) ->                                                             *)
(*          ignore (visitCilOffset (self :> cilVisitor) off);                              *)
(*          if (!considerVariableUse) v then begin                                         *)
(*            varUsed := VS.add v !varUsed                                                 *)
(*          end;                                                                           *)
(*          SkipChildren (* So that we do not see the v *)                                 *)
(*                                                                                         *)
(*      | AddrOf (Var v, off)                                                              *)
(*      | StartOf (Var v, off) ->                                                          *)
(*          ignore (visitCilOffset (self :> cilVisitor) off);                              *)
(*          if (!considerVariableAddrOfAsUse) v then                                       *)
(*            varUsed := VS.add v !varUsed;                                                *)
(*          SkipChildren                                                                   *)
(*                                                                                         *)
(*      | SizeOfE _                                                                        *)
(*      | AlignOfE _ when !ignoreSizeof -> SkipChildren                                    *)
(*                                                                                         *)
(*      | _ -> DoChildren                                                                  *)
(*                                                                                         *)
(*    (* For function calls, do the transitive variable read/defs *)                       *)
(*    method vinst i = match i with                                                        *)
(*        Call (lvo, f, args, _) -> begin                                                  *)
(*            (* we will compute the use and def that appear in * this instruction. We   *)*)
(*            (* also add in the stuff computed by * getUseDefFunctionRef                *)*)
(*            let use, def, args' = !getUseDefFunctionRef f args in                        *)
(*            varUsed := VS.union !varUsed use;                                            *)
(*            varDefs := VS.union !varDefs def;                                            *)
(*                                                                                         *)
(*            (* Now visit the children of "Call (lvo, f, args', _)" *)                    *)
(*            let self: cilVisitor = (self :> cilVisitor) in                               *)
(*            (match lvo with None -> ()                                                   *)
(*              | Some lv -> ignore (visitCilLval self lv));                               *)
(*            ignore (visitCilExpr self f);                                                *)
(*            List.iter (fun arg -> ignore (visitCilExpr self arg)) args';                 *)
(*            SkipChildren                                                                 *)
(*          end                                                                            *)
(*      | Asm(_, _, slvl, _, _, _) -> List.iter (fun (_, s, lv) ->                         *)
(*                  match lv with (Var v, off) ->                                          *)
(*                      if s.[0] = '+' then                                                *)
(*                        varUsed := VS.add v !varUsed;                                    *)
(*                  | _ -> ()) slvl;                                                       *)
(*          DoChildren                                                                     *)
(*      | _ -> DoChildren                                                                  *)
(*                                                                                         *)
(*  end                                                                                    *)
(*                                                                                         *)
(*  (** Compute the use/def information for an instruction *)                              *)
(*  let computeUseDefInstr ?(acc_used = VS.empty)                                          *)
(*      ?(acc_defs = VS.empty)                                                             *)
(*      (i: instr) : VS.t * VS.t =                                                         *)
(*    let varUsed, varDefs = ref acc_used, ref acc_defs in                                 *)
(*    ignore (visitCilInstr (new useDefVisitorClass varUsed varDefs) i);                   *)
(*    !varUsed, !varDefs                                                                   *)
(*                                                                                         *)
(*  (** Compute the use/def information for a statement kind. Do not descend into          *)
(*  * the nested blocks. *)                                                                *)
(*  let computeUseDefStmtKind ?(acc_used = VS.empty)                                       *)
(*      ?(acc_defs = VS.empty)                                                             *)
(*      (sk: stmtkind) : VS.t * VS.t =                                                     *)
(*    let varUsed, varDefs = ref acc_used, ref acc_defs in                                 *)
(*    let ve e = ignore (visitCilExpr (new useDefVisitorClass varUsed varDefs) e) in       *)
(*    let _ =                                                                              *)
(*      match sk with                                                                      *)
(*        Return (None, _) -> ()                                                           *)
(*      | Return (Some e, _) -> ve e                                                       *)
(*      | If (e, _, _, _) -> ve e                                                          *)
(*      | Break _ | Goto _ | Continue _ -> ()                                              *)
(*      | Loop (_, _, _, _) -> ()                                                          *)
(*      | Switch (e, _, _, _) -> ve e                                                      *)
(*      | Instr il ->                                                                      *)
(*          List.iter (fun i ->                                                            *)
(*                  ignore (visitCilInstr (new useDefVisitorClass varUsed varDefs) i)) il  *)
(*      | TryExcept _ | TryFinally _ -> ()                                                 *)
(*      | Block _ -> ()                                                                    *)
(*    in                                                                                   *)
(*    !varUsed, !varDefs                                                                   *)
(*end                                                                                      *)

(*  let urefs = Hashtbl.create 3 in                                                 *)
(*  Hashtbl.iter (fun k _ -> Hashtbl.replace urefs k (Uref.uref k)) reuseCandidates;*)
(*  let getUref k = Hashtbl.find urefs k in                                         *)
(*  Hashtbl.iter (fun k v ->                                                        *)
(*    VS.iter (fun e -> Uref.union (getUref k,getUref e.vid)) v) reuseCandidates;   *)
(*  let repalceTable = Hashtbl.create 3 in                                              *)
(*  Hashtbl.iter (fun k uref -> Hashtbl.replace repalceTable k (Uref.deref uref)) urefs;*)

(*class cfgPruningModifier nonzeros = object (self) inherit nopCilVisitor*)
(*    method vstmt stm = match stm.skind with                            *)
(*      | Loop (blk,_,_,_) ->                                            *)
(*        E.log ":%a\n" d_plainstmt stm;                                 *)
(*        SkipChildren                                                   *)
(*      | _ -> DoChildren                                                *)
(*end                                                                    *)

(*let cfgPrune nonZeros (fil:file) =                   *)
(*  let work fundec ls =                               *)
(*    if VS.mem ls.vi nonZeros && ls.body !=[] then (  *)
(*      E.log "cfgPrune:%a\n" d_stmt (List.hd ls.body);*)
(*      E.log "%d\n" (List.length                      *)
(*      );                                             *)
(*    None in                                          *)
(*  iterLoops work fil                                 *)

(*class cfgPruneModifier nonZeros = object(self)                             *)
(*  inherit lidoStream                                                       *)
(*  method vblock blk =                                                      *)
(*    let rec loop stk = function                                            *)
(*       | [] -> ()                                                          *)
(*      | x:: xs -> begin                                                    *)
(*            ignore (getLoopStruct (take 1 stk @ [x]) >>= fun ls ->         *)
(*                (match take 1 stk with                                     *)
(*                   | [s] when ls.body !=[] ->                              *)
(*                        (match ls.bound with                               *)
(*                          | Lval(Var vi,NoOffset) when VS.mem vi nonZeros->*)
(*                            E.log "cfgPrune:%a\n" d_stmt x;                *)
(*                            E.log "bound:%a\n" d_plainexp ls.bound;        *)
(*                            E.log "%d\n" (List.length x.succs)             *)
(*                            | _ -> ());                                    *)
(*                      | _ -> ());                                          *)
(*                    None                                                   *)
(*              );                                                           *)
(*            loop (x:: stk) xs                                              *)
(*          end in                                                           *)
(*    loop [] blk.bstmts;                                                    *)
(*    DoChildren                                                             *)
(*end                                                                        *)
(*                                                                           *)
(*let cfgPrune nonZeros (f:fundec) =                                         *)
(*  ignore (visitCilFunction (new cfgPruneModifier nonZeros) f)              *)

(*  let rec addSucc (n: stmt) =                         *)
(*(*    E.log "addSucc:%a\n" d_stmt n; *)               *)
(*    match n.skind with                                *)
(*    | Block blk when blk.bstmts!=[]-> addBlockSucc blk*)
(*     | _ ->                                           *)
(*        if not (List.memq n s.succs) then             *)
(*          s.succs <- n::s.succs;                      *)
(*        if not (List.memq s n.preds) then             *)
(*          n.preds <- s::n.preds                       *)
(*  and addOptionSucc (n: stmt option) =                *)
(*    match n with                                      *)
(*      None -> ()                                      *)
(*    | Some n' -> addSucc n'                           *)
(*  and addBlockSucc (b: block) =                       *)
(*    match b.bstmts with                               *)
(*      [] -> addOptionSucc next                        *)
(*    | hd::_ -> addSucc hd                             *)

(*let findReusesFun arrs allocLenSet conflicts (_f:fundec) =                              *)
(*    let f2 = copyFunction _f (_f.svar.vname^"_") in                                     *)
(*(*    let f2 = Lidoutil.doOneInstrFun f1 in*)                                           *)
(*    E.log "In %s:\n" f2.svar.vname;                                                     *)
(*(*    Cfg.clearCFGinfo f2;   *)                                                         *)
(*(*    ignore (Cfg.cfgFun f2);*)                                                         *)
(*    let f' = Lidoutil.cfgPrune allocLenSet f2 in                                        *)
(*(*    E.log "dumpGlobal\n";                                      *)                     *)
(*(*    dumpGlobal defaultCilPrinter stdout (GFun (f',locUnknown));*)                     *)
(*(*    E.log "\n";                                                *)                     *)
(*(*    let f' = Lidoutil.till_nochange_clean_block_fun f3 in*)                           *)
(*    Cfg.clearCFGinfo f';                                                                *)
(*    ignore (Cfg.cfgFun f');                                                             *)
(*(*    Liveness.computeLiveness f';*)                                                    *)
(*    Lidoutil.ArrayLiveness.computeLiveness f';                                          *)
(*    let checkStm stm = match stm.skind with                                             *)
(*      | Instr ils ->                                                                    *)
(*(*        assert (List.length ils == 1);*)                                              *)
(*        let ls = VS.inter arrs (Lidoutil.ArrayLiveness.getStmLiveSet stm) in            *)
(*        let u,d = Lidoutil.ArrayUsedef.computeUseDefStmt stm in                         *)
(*        if not (VS.is_empty ls) then (                                                  *)
(*            E.log "At %d stmt %a\n" stm.sid d_stmt stm;                                 *)
(*(*          E.log "succs:\n";                                    *)                     *)
(*(*          List.iter (fun stm -> E.log "%d " stm.sid) stm.succs;*)                     *)
(*(*          E.log "\n";                                          *)                     *)
(*(*          E.log "preds:\n";                                    *)                     *)
(*(*          List.iter (fun stm -> E.log "%d " stm.sid) stm.preds;*)                     *)
(*(*          E.log "\n";                                          *)                     *)
(*          E.log "lives:\n";                                                             *)
(*            VS.iter (fun e -> E.log "%d " e.vid) ls;                                    *)
(*            E.log "\n";                                                                 *)
(*          E.log "uses:\n";                                                              *)
(*            VS.iter (fun e -> E.log "%d " e.vid) u;                                     *)
(*            E.log "\n";                                                                 *)
(*          E.log "defs:\n";                                                              *)
(*            VS.iter (fun e -> E.log "%d " e.vid) d;                                     *)
(*            E.log "\n"                                                                  *)
(*        );                                                                              *)
(*        VS.iter (fun e ->                                                               *)
(*          let vs =  VS.remove e                                                         *)
(*          (VS.union (try Hashtbl.find conflicts e.vid with Not_found -> VS.empty) ls) in*)
(*           if vs != VS.empty then Hashtbl.replace conflicts e.vid vs                    *)
(*        ) ls                                                                            *)
(*      | _ -> () in                                                                      *)
(*    List.iter checkStm (List.rev (Lidoutil.allStmtsFun f'))                             *)
(*(*    ignore (visitCilFunction (new checkReuse arrs conflicts) f')*)                    *)

(*      let u,d = Lidoutil.ArrayUsedef.computeUseDefStmt stm in*)
(*(*      E.log "size of ls is %d\n" (VS.cardinal ls);*)       *)
(*      if VS.cardinal ls >0 then (                            *)
(*      E.log "checkReuse: At %d stmt %a\n" stm.sid d_stmt stm;*)
(*      VS.iter (fun e -> E.log "%d " e.vid) ls;               *)
(*      E.log "\n";                                            *)
(*      E.log "succs:\n";                                      *)
(*      List.iter (fun s -> E.log "%d " s.sid) stm.succs;      *)
(*      E.log "\n";                                            *)
(*          E.log "uses:\n";                                   *)
(*            VS.iter (fun e -> E.log "%d " e.vid) u;          *)
(*            E.log "\n";                                      *)
(*          E.log "defs:\n";                                   *)
(*            VS.iter (fun e -> E.log "%d " e.vid) d;          *)
(*            E.log "\n"                                       *)
(*      );                                                     *)

(*(*  VS.iter (fun e -> VS.iter (fun e' ->                                *)*)
(*(*    if not (compareTypes e.vtype e'.vtype) then                       *)*)
(*(*      Hashtbl.replace conflicts e.vid (VS.add e'                      *)*)
(*(*        (try Hashtbl.find conflicts e.vid with Not_found -> VS.empty))*)*)
(*(*      ) arrs) arrs;                                                   *)*)
(*  let aux (f:fundec) =                                                    *)
(*    Liveness.computeLiveness f;                                           *)
(*    ignore (visitCilFunction (new checkReuse arrs conflicts) f) in        *)
(*  iterFunctions aux fil;                                                  *)
(*  Lidoutil.computeGlobalLiveness fil;                         *)
(*  visitCilFileSameGlobals (new checkReuse arrs conflicts) fil;*)
(*(*  visitCilFileSameGlobals (new checkReuse arrs reuseCandidates) f;*)    *)

(*  E.log "findReusesFun\n";                                               *)
(*  Lidoutil.iterFunctions (findReusesFun arrs !allocLenSet conflicts) fil;*)

(*let cfgPrune nonZeros (f: fundec) =                                    *)
(*  let work fundec ls stms = match ls.bound with                        *)
(*      | Lval(Var vi, NoOffset) when VS.mem vi nonZeros && ls.body!=[]->*)
(*          E.log "cfgPrune:\n";                                         *)
(*          List.iter (E.log "%a\n" d_plainstmt) ls.body;                *)
(*          E.log "bound:%a\n" d_plainexp ls.bound;                      *)
(*          Some (ls.body)                                               *)
(*      | _ -> None in                                                   *)
(*  visitCilFunction (new loopStream work) f                             *)

(*  let activeStructures = getActiveStructures f in*)
(*  E.log "Active structures\n";                                *)
(*  List.iter (fun ci -> E.log "%s " ci.cname) activeStructures;*)
(*  E.log "\n";                                                 *)
