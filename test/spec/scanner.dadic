/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

double dotproduct(double *a , double *b , unsigned int len ) ;
typedef unsigned int size_t;
typedef long __off_t;
typedef long long __off64_t;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
struct _IO_FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15U * sizeof(int ) - 2U * sizeof(void *)] ;
};
struct __anonstruct_f1_neuron_19 {

};
typedef struct __anonstruct_f1_neuron_19 f1_neuron;
struct __anonstruct_xyz_20 {
   double y ;
   int reset ;
};
typedef struct __anonstruct_xyz_20 xyz;
extern struct _IO_FILE *stdout ;
extern struct _IO_FILE *stderr ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
__inline static int atoi(char const   *__nptr )  __attribute__((__pure__)) ;
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) ;
extern long __strtol_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                              int __base , int __group ) ;
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
  return (tmp);
}
}
__inline static int atoi(char const   *__nptr )  __attribute__((__pure__)) ;
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
extern int rand(void) ;
extern void srand(unsigned int __seed ) ;
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern void free(void *__ptr ) ;
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
extern double sqrt(double __x ) ;
extern double fabs(double __x )  __attribute__((__const__)) ;
extern int open(char const   *__file , int __oflag  , ...) ;
void alloc_td_bu(void) ;
unsigned char **cimage  ;
double *tds  ;
double *bus  ;
int lwidth  ;
int lheight  ;
int width  ;
int height  ;
int numinputs  ;
long i  ;
long j  ;
int pass_flag  ;
int highx[2]  ;
int highy[2]  ;
double highest_confidence[2]  ;
int set_high[2]  ;
FILE *fp  ;
int winner  ;
int numf1s  ;
int numf2s  ;
int resonant  ;
int cp  ;
int numpatterns  ;
double a  ;
double b  ;
double c  ;
double d  ;
double theta  ;
double delta_t  ;
double rho  ;
f1_neuron *f1_layer  ;
double *f1_layer_I ;
double *f1_layer_W ;
double *f1_layer_X ;
double *f1_layer_V ;
double *f1_layer_U ;
double *f1_layer_P ;
double *f1_layer_Q ;
double *f1_layer_R ;
xyz *Y  ;
double g(int i___0 ) 
{ double result ;

  {
  if (i___0 != winner) {
    result = (double )0;
  } else {
    if ((Y + i___0)->y > (double )0) {
      result = d;
    } else {
      result = (double )0;
    }
  }
  return (result);
}
}
void find_match(void) 
{ int i___0 ;

  {
  winner = 0;
  i___0 = 0;
  while (i___0 < numf2s) {
    if ((Y + i___0)->y > (Y + winner)->y) {
      winner = i___0;
    }
    i___0 ++;
  }
  return;
}
}
double simtest(void) 
{ int j___0 ;
  double sum ;
  double norm ;
  double temp_sum ;

  {
  norm = (double )0;
  sum = norm;
  j___0 = 0;
  norm = dotproduct(f1_layer_P, f1_layer_P, numf1s - 0);
  j___0 = numf1s;
  norm = sqrt(norm);
  norm *= c;
  sum += norm;
  norm = (double )0;
  j___0 = 0;
  while (j___0 < numf1s) {
    temp_sum = *(f1_layer_W + j___0) * *(f1_layer_W + j___0);
    norm += temp_sum;
    j___0 ++;
  }
  norm = sqrt(norm);
  sum += norm;
  j___0 = 0;
  while (j___0 < numf1s) {
    *(f1_layer_R + j___0) = (*(f1_layer_W + j___0) + c * *(f1_layer_P + j___0)) / sum;
    j___0 ++;
  }
  norm = (double )0;
  j___0 = 0;
  norm = dotproduct(f1_layer_R, f1_layer_R, numf1s - 0);
  j___0 = numf1s;
  norm = sqrt(norm);
  return (norm);
}
}
double simtest2(void) 
{ int j___0 ;
  double Su ;
  double Sp ;
  double numerator ;
  double denom ;
  double su ;
  double sp ;
  double su2 ;
  double sp2 ;
  double sup ;
  double r ;
  double e ;
  double tmp ;
  double tmp___0 ;

  {
  e = 0.0000000001;
  numerator = 0.0;
  sp2 = numerator;
  su2 = sp2;
  sup = su2;
  sp = sup;
  su = sp;
  j___0 = 0;
  while (j___0 < numf1s) {
    su += *(f1_layer_W + j___0);
    sp += *(f1_layer_P + j___0);
    su2 += *(f1_layer_W + j___0) * *(f1_layer_W + j___0);
    sp2 += *(f1_layer_P + j___0) * *(f1_layer_P + j___0);
    sup += *(f1_layer_W + j___0) * *(f1_layer_P + j___0);
    j___0 ++;
  }
  Su = ((double )numf1s * su2 - su * su) / ((double )numf1s * ((double )numf1s - 1.0));
  Su = sqrt(Su);
  Sp = ((double )numf1s * sp2 - sp * sp) / ((double )numf1s * ((double )numf1s - 1.0));
  Sp = sqrt(Sp);
  numerator = (double )numf1s * sup - su * sp;
  tmp = sqrt((double )numf1s * su2 - su * su);
  tmp___0 = sqrt((double )numf1s * sp2 - sp * sp);
  denom = tmp * tmp___0;
  r = (numerator + e) / (denom + e);
  if (numerator == (double )0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"potential div by zero");
    r = (double )1;
  } else {
    if (denom == (double )0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"potential div by zero");
      r = (double )1;
    }
  }
  if (numerator != (double )0) {
    if (denom == (double )0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"div by zero");
      r = (double )1;
    }
  }
  r *= r;
  return (r);
}
}
void weightadj(void) 
{ int i___0 ;
  int j___0 ;
  int k ;
  double temp ;
  double er ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  er = 0.000000001;
  i___0 = winner;
  k = 0;
  while (k < 1) {
    resonant = 0;
    j___0 = 0;
    while (j___0 < numf1s) {
      temp = *(tds + (i___0 * (unsigned int )numf1s + j___0));
      tmp = g(i___0);
      *(tds + (i___0 * (unsigned int )numf1s + j___0)) += (tmp * (*(f1_layer_P + j___0) - *(tds + (i___0 * (unsigned int )numf1s + j___0)))) * delta_t;
      tmp___0 = fabs(temp - *(tds + (i___0 * (unsigned int )numf1s + j___0)));
      if (tmp___0 <= er) {
        resonant = 1;
      }
      j___0 ++;
    }
    j___0 = 0;
    while (j___0 < numf1s) {
      temp = *(bus + (i___0 * (unsigned int )numf1s + j___0));
      tmp___1 = g(i___0);
      *(bus + (i___0 * (unsigned int )numf1s + j___0)) += (tmp___1 * (*(f1_layer_P + j___0) - *(bus + (i___0 * (unsigned int )numf1s + j___0)))) * delta_t;
      tmp___2 = fabs(temp - *(bus + (i___0 * (unsigned int )numf1s + j___0)));
      if (tmp___2 <= er) {
        if (resonant) {
          resonant = 1;
        } else {
          resonant = 0;
        }
      } else {
        resonant = 0;
      }
      j___0 ++;
    }
    k ++;
  }
  return;
}
}
void init_globs(int mode ) 
{ double tmp ;
  double tmp___0 ;

  {
  if (mode == 0) {
    a = (double )255;
    b = 0.0;
    c = 0.11;
    d = 0.9;
    tmp = sqrt((double )numf1s);
    theta = (double )1 / tmp;
    delta_t = 0.1;
    rho = 0.70;
  } else {
    a = (double )255;
    b = 10.0;
    c = 0.11;
    d = 0.9;
    tmp___0 = sqrt((double )numf1s);
    theta = (double )1 / tmp___0;
    delta_t = 0.7;
    rho = 0.95;
  }
  return;
}
}
void init_net(void) 
{ int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;

  {
  __cil_tmp5 = malloc(((unsigned int )numf1s * 2U) * sizeof(double ));
  f1_layer_I = (double *)__cil_tmp5;
  __cil_tmp6 = malloc((unsigned int )numf1s * sizeof(double ));
  f1_layer_W = __cil_tmp6;
  __cil_tmp7 = malloc((unsigned int )numf1s * sizeof(double ));
  f1_layer_W = __cil_tmp7;
  __cil_tmp8 = malloc((unsigned int )numf1s * sizeof(double ));
  f1_layer_W = __cil_tmp8;
  __cil_tmp9 = malloc((unsigned int )numf1s * sizeof(double ));
  f1_layer_W = __cil_tmp9;
  __cil_tmp10 = malloc((unsigned int )numf1s * sizeof(double ));
  f1_layer_P = __cil_tmp10;
  __cil_tmp11 = malloc((unsigned int )numf1s * sizeof(double ));
  f1_layer_Q = __cil_tmp11;
  __cil_tmp12 = malloc((unsigned int )numf1s * sizeof(double ));
  f1_layer_R = __cil_tmp12;
  tmp = malloc((unsigned int )numf1s * sizeof(f1_neuron ));
  f1_layer = (f1_neuron *)tmp;
  if ((unsigned int )f1_layer == (unsigned int )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc error in init_net\n");
    exit(1);
  }
  i___0 = 0;
  while (i___0 < numf1s) {
    if (f1_layer_I + (0 * (unsigned int )numf1s + i___0) == (unsigned int )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc error in init_net\n");
      exit(1);
    }
    *(f1_layer_W + i___0) = (double )0;
    *(f1_layer_W + i___0) = (double )0;
    *(f1_layer_W + i___0) = (double )0;
    *(f1_layer_W + i___0) = (double )0;
    *(f1_layer_P + i___0) = (double )0;
    *(f1_layer_Q + i___0) = (double )0;
    *(f1_layer_R + i___0) = (double )0;
    i___0 ++;
  }
  tmp___1 = malloc((unsigned int )numf2s * sizeof(xyz ));
  Y = (xyz *)tmp___1;
  if ((unsigned int )Y == (unsigned int )((void *)0)) {
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Malloc error for Y\n");
    exit(1);
  }
  return;
}
}
void analog_conv(void) 
{ int j___0 ;
  int lines ;
  int k ;
  int x1 ;
  int x2 ;
  double y1___0 ;
  double y2 ;

  {
  fscanf((FILE * __restrict  )fp, (char const   * __restrict  )"%i", & lines);
  j___0 = 0;
  while (j___0 < lines) {
    fscanf((FILE * __restrict  )fp, (char const   * __restrict  )"%i %f %i %f", & x1,
           & y1___0, & x2, & y2);
    k = x1;
    while (k <= x2) {
      *(f1_layer_I + (cp * (unsigned int )numf1s + k)) = ((y2 - y1___0) / (double )(x2 - x1)) * (double )(k - x2) + y2;
      k ++;
    }
    j___0 ++;
  }
  return;
}
}
void get_pat(void) 
{ int i___0 ;

  {
  i___0 = 0;
  while (i___0 < numf1s) {
    fscanf((FILE * __restrict  )fp, (char const   * __restrict  )"%f", f1_layer_I + (cp * (unsigned int )numf1s + i___0));
    i___0 ++;
  }
  return;
}
}
void show_pat(void) 
{ int i___0 ;

  {
  i___0 = 0;
  while (i___0 < numf1s) {
    if (i___0 % 5 == 0) {
      printf((char const   * __restrict  )"\n");
    }
    printf((char const   * __restrict  )" %8.5f ", *(f1_layer_I + (cp * (unsigned int )numf1s + i___0)));
    i___0 ++;
  }
  printf((char const   * __restrict  )"\n\n");
  return;
}
}
void reset_nodes(void) 
{ int i___0 ;

  {
  i___0 = 0;
  while (i___0 < numf1s) {
    *(f1_layer_W + i___0) = 0.0;
    *(f1_layer_W + i___0) = 0.0;
    *(f1_layer_W + i___0) = 0.0;
    *(f1_layer_W + i___0) = 0.0;
    *(f1_layer_P + i___0) = 0.0;
    *(f1_layer_Q + i___0) = 0.0;
    *(f1_layer_R + i___0) = 0.0;
    i___0 ++;
  }
  i___0 = 0;
  while (i___0 < numf2s) {
    (Y + i___0)->y = 0.0;
    (Y + i___0)->reset = 0;
    i___0 ++;
  }
  winner = 0;
  resonant = 0;
  return;
}
}
void reset_nodes2(void) 
{ int i___0 ;

  {
  i___0 = 0;
  while (i___0 < numf1s) {
    *(f1_layer_W + i___0) = 0.0;
    *(f1_layer_W + i___0) = 0.0;
    *(f1_layer_W + i___0) = 0.0;
    *(f1_layer_W + i___0) = 0.0;
    *(f1_layer_P + i___0) = 0.0;
    *(f1_layer_Q + i___0) = 0.0;
    *(f1_layer_R + i___0) = 0.0;
    i___0 ++;
  }
  i___0 = 0;
  while (i___0 < numf2s) {
    (Y + i___0)->y = 0.0;
    i___0 ++;
  }
  winner = 0;
  resonant = 0;
  return;
}
}
void print_weights(void) 
{ int i___0 ;
  int j___0 ;

  {
  printf((char const   * __restrict  )"============  TOP down WEIGHTS ==============\n");
  i___0 = 0;
  while (i___0 < numf1s) {
    j___0 = 0;
    while (j___0 < numf2s) {
      if (j___0 == numf2s - 1) {
        printf((char const   * __restrict  )" %8.16f\n", *(tds + (j___0 * (unsigned int )numf1s + i___0)));
      } else {
        printf((char const   * __restrict  )" %8.16f ", *(tds + (j___0 * (unsigned int )numf1s + i___0)));
      }
      j___0 ++;
    }
    i___0 ++;
  }
  printf((char const   * __restrict  )"============  BOTTOM up WEIGHTS ==============\n");
  i___0 = 0;
  while (i___0 < numf1s) {
    j___0 = 0;
    while (j___0 < numf2s) {
      if (j___0 == numf2s - 1) {
        printf((char const   * __restrict  )" %8.16f\n", *(bus + (j___0 * (unsigned int )numf1s + i___0)));
      } else {
        printf((char const   * __restrict  )" %8.16f ", *(bus + (j___0 * (unsigned int )numf1s + i___0)));
      }
      j___0 ++;
    }
    i___0 ++;
  }
  return;
}
}
void print_f12(void) 
{ int j___0 ;

  {
  printf((char const   * __restrict  )"\n\n");
  j___0 = 0;
  while (j___0 < numf2s) {
    printf((char const   * __restrict  )" j = %i  Y= %9.7f\n", j___0, (Y + j___0)->y);
    j___0 ++;
  }
  return;
}
}
void train_match(int spot ) 
{ int j___0 ;
  int matched ;
  int f1res ;
  int mt ;
  int ti ;
  int tj ;
  int tresult ;
  double tnorm ;
  double xr ;
  double qr ;
  double tsum ;
  double ttemp ;
  char matchtest ;
  double match_confidence ;

  {
  f1res = 0;
  reset_nodes();
  cp = spot;
  matched = 0;
  while (! matched) {
    f1res = 0;
    j___0 = 0;
    while (1) {
      if (j___0 < 9) {
        if (! (! f1res)) {
          break;
        }
      } else {
        break;
      }
      tnorm = (double )0;
      ti = 0;
      while (ti < numf1s) {
        *(f1_layer_W + ti) = *(f1_layer_I + (cp * (unsigned int )numf1s + ti)) + a * *(f1_layer_W + ti);
        tnorm += *(f1_layer_W + ti) * *(f1_layer_W + ti);
        ti ++;
      }
      tnorm = sqrt(tnorm);
      tj = 0;
      while (tj < numf1s) {
        *(f1_layer_W + tj) /= tnorm;
        tj ++;
      }
      tnorm = (double )0;
      ti = 0;
      while (ti < numf1s) {
        if (*(f1_layer_W + ti) < theta) {
          xr = (double )0;
        } else {
          xr = *(f1_layer_W + ti);
        }
        if (*(f1_layer_Q + ti) < theta) {
          qr = (double )0;
        } else {
          qr = *(f1_layer_Q + ti);
        }
        *(f1_layer_W + ti) = xr + b * qr;
        tnorm += *(f1_layer_W + ti) * *(f1_layer_W + ti);
        ti ++;
      }
      tnorm = sqrt(tnorm);
      tj = 0;
      while (tj < numf1s) {
        *(f1_layer_W + tj) /= tnorm;
        tj ++;
      }
      tnorm = (double )0;
      tsum = (double )0;
      tresult = 1;
      ti = 0;
      while (ti < numf1s) {
        tsum = (double )0;
        ttemp = *(f1_layer_P + ti);
        tj = spot;
        if (winner < numf2s) {
          if (spot <= winner) {
            if ((Y + winner)->y > (double )0) {
              tsum += *(tds + (winner * (unsigned int )numf1s + ti)) * d;
            }
          }
        }
        *(f1_layer_P + ti) = *(f1_layer_W + ti) + tsum;
        tnorm += *(f1_layer_P + ti) * *(f1_layer_P + ti);
        if (ttemp != *(f1_layer_P + ti)) {
          tresult = 0;
        }
        ti ++;
      }
      f1res = tresult;
      tnorm = sqrt(tnorm);
      tj = 0;
      while (tj < numf1s) {
        *(f1_layer_Q + tj) = *(f1_layer_P + tj);
        tj ++;
      }
      tj = spot;
      while (tj < numf2s) {
        (Y + tj)->y = (double )0;
        if (! (Y + tj)->reset) {
          ti = 0;
          (Y + tj)->y = dotproduct(f1_layer_P, bus + tj * (unsigned int )numf1s, numf1s - 0);
          ti = numf1s;
        }
        tj ++;
      }
      winner = 0;
      ti = spot;
      while (ti < numf2s) {
        if ((Y + ti)->y > (Y + winner)->y) {
          winner = ti;
        }
        ti ++;
      }
      j___0 ++;
    }
    match_confidence = simtest();
    if (match_confidence > rho) {
      weightadj();
      matched = 1;
    } else {
      (Y + winner)->y = (double )0;
      (Y + winner)->reset = 1;
      matchtest = (char)0;
      mt = spot;
      while (mt < numf2s) {
        if ((Y + mt)->reset == 0) {
          matchtest = (char)1;
        }
        mt ++;
      }
      if (matchtest) {
        find_match();
      } else {
        matched = 1;
      }
    }
  }
  return;
}
}
void match(void) 
{ int j___0 ;
  int matched ;
  int f1res ;
  int mt ;
  int ti ;
  int tj ;
  int tresult ;
  double tnorm ;
  double xr ;
  double qr ;
  double tsum ;
  double ttemp ;
  char matchtest ;
  double match_confidence ;

  {
  f1res = 0;
  cp = 0;
  reset_nodes();
  matched = 0;
  while (! matched) {
    reset_nodes2();
    f1res = 0;
    j___0 = 0;
    while (1) {
      if (j___0 < 9) {
        if (! (! f1res)) {
          break;
        }
      } else {
        break;
      }
      tnorm = (double )0;
      ti = 0;
      while (ti < numf1s) {
        *(f1_layer_W + ti) = *(f1_layer_I + (cp * (unsigned int )numf1s + ti)) + a * *(f1_layer_W + ti);
        tnorm += *(f1_layer_W + ti) * *(f1_layer_W + ti);
        ti ++;
      }
      tnorm = sqrt(tnorm);
      tj = 0;
      while (tj < numf1s) {
        *(f1_layer_W + tj) /= tnorm;
        tj ++;
      }
      tnorm = (double )0;
      ti = 0;
      while (ti < numf1s) {
        if (*(f1_layer_W + ti) < theta) {
          xr = (double )0;
        } else {
          xr = *(f1_layer_W + ti);
        }
        if (*(f1_layer_Q + ti) < theta) {
          qr = (double )0;
        } else {
          qr = *(f1_layer_Q + ti);
        }
        *(f1_layer_W + ti) = xr + b * qr;
        tnorm += *(f1_layer_W + ti) * *(f1_layer_W + ti);
        ti ++;
      }
      tnorm = sqrt(tnorm);
      tj = 0;
      while (tj < numf1s) {
        *(f1_layer_W + tj) /= tnorm;
        tj ++;
      }
      tnorm = (double )0;
      tsum = (double )0;
      tresult = 1;
      ti = 0;
      while (ti < numf1s) {
        tsum = (double )0;
        ttemp = *(f1_layer_P + ti);
        tj = 0;
        if (winner < numf2s) {
          if (0 <= winner) {
            if ((Y + winner)->y > (double )0) {
              tsum += *(tds + (winner * (unsigned int )numf1s + ti)) * d;
            }
          }
        }
        *(f1_layer_P + ti) = *(f1_layer_W + ti) + tsum;
        tnorm += *(f1_layer_P + ti) * *(f1_layer_P + ti);
        if (ttemp != *(f1_layer_P + ti)) {
          tresult = 0;
        }
        ti ++;
      }
      f1res = tresult;
      tnorm = sqrt(tnorm);
      tj = 0;
      while (tj < numf1s) {
        *(f1_layer_Q + tj) = *(f1_layer_P + tj);
        tj ++;
      }
      tj = 0;
      while (tj < numf2s) {
        (Y + tj)->y = (double )0;
        if (! (Y + tj)->reset) {
          ti = 0;
          (Y + tj)->y = dotproduct(f1_layer_P, bus + tj * (unsigned int )numf1s, numf1s - 0);
          ti = numf1s;
        }
        tj ++;
      }
      winner = 0;
      ti = 0;
      while (ti < numf2s) {
        if ((Y + ti)->y > (Y + winner)->y) {
          winner = ti;
        }
        ti ++;
      }
      j___0 ++;
    }
    match_confidence = simtest2();
    if (match_confidence > rho) {
      if (winner != numf2s - 1) {
        pass_flag = 1;
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"F2 neuron %d passes vigilance with a value of %0.4f\n",
                winner, match_confidence);
        print_f12();
        if (match_confidence > highest_confidence[winner]) {
          highest_confidence[winner] = match_confidence;
          set_high[winner] = 1;
        }
      }
      matched = 1;
    } else {
      (Y + winner)->y = (double )0;
      (Y + winner)->reset = 1;
      matchtest = (char)0;
      mt = 0;
      while (mt < numf2s) {
        if ((Y + mt)->reset == 0) {
          matchtest = (char)1;
        }
        mt ++;
      }
      if (matchtest) {
        find_match();
      } else {
        matched = 1;
      }
    }
  }
  return;
}
}
extern int ( /* missing proto */  read)() ;
void loadimage(char *input_file ) 
{ int i___0 ;
  int j___0 ;
  int fd ;
  char buffer[64] ;
  char *superbuffer ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  fd = open((char const   *)input_file, 0);
  if (fd == -1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error opening %s\n",
            input_file);
    exit(1);
  }
  read(fd, buffer, 8);
  read(fd, buffer, 4);
  i___0 = 0;
  while (i___0 < 4) {
    if ((int )buffer[i___0] != 32) {
      width = (width * 10 + (int )buffer[i___0]) - 48;
    }
    i___0 ++;
  }
  read(fd, buffer, 4);
  i___0 = 0;
  while (i___0 < 4) {
    if ((int )buffer[i___0] != 32) {
      height = (height * 10 + (int )buffer[i___0]) - 48;
    }
    i___0 ++;
  }
  tmp = malloc((unsigned int )(width * height) * sizeof(char ));
  superbuffer = (char *)tmp;
  if ((unsigned int )superbuffer == (unsigned int )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Problems with malloc in loadimage()\n");
    exit(1);
  }
  tmp___0 = malloc(sizeof(unsigned char *) * (unsigned int )height);
  cimage = (unsigned char **)tmp___0;
  if ((unsigned int )cimage == (unsigned int )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Problems with malloc in loadimage()\n");
    exit(1);
  }
  i___0 = 0;
  while (i___0 < height) {
    tmp___1 = malloc((unsigned int )width * sizeof(unsigned char ));
    *(cimage + i___0) = (unsigned char *)tmp___1;
    if ((unsigned int )*(cimage + i___0) == (unsigned int )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Problems with malloc in loadimage()\n");
      exit(1);
    }
    i___0 ++;
  }
  read(fd, superbuffer, width * height);
  i___0 = 0;
  while (i___0 < height) {
    j___0 = 0;
    while (j___0 < width) {
      *(*(cimage + i___0) + j___0) = (unsigned char )*(superbuffer + (i___0 * width + j___0));
      j___0 ++;
    }
    i___0 ++;
  }
  return;
}
}
void load_weights(char *weightfile ) 
{ double a___0 ;
  long i___0 ;
  long j___0 ;
  FILE *inp ;

  {
  inp = fopen((char const   * __restrict  )weightfile, (char const   * __restrict  )"r");
  if ((unsigned int )inp == (unsigned int )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unable to open %s\n",
            weightfile);
    exit(1);
  }
  printf((char const   * __restrict  )"made it to load_weights\n");
  fscanf((FILE * __restrict  )inp, (char const   * __restrict  )"%d %d", & lwidth,
         & lheight);
  numinputs = lwidth * lheight;
  numf1s = numinputs;
  numf2s = numpatterns + 1;
  alloc_td_bu();
  j___0 = 0L;
  i___0 = 0L;
  while (i___0 < (long )numf1s) {
    fscanf((FILE * __restrict  )inp, (char const   * __restrict  )"%le", & a___0);
    *(tds + (j___0 * (unsigned int )numf1s + i___0)) = a___0;
    *(bus + (j___0 * (unsigned int )numf1s + i___0)) = *(tds + (j___0 * (unsigned int )numf1s + i___0));
    i___0 ++;
  }
  return;
}
}
void alloc_td_bu(void) 
{ void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  tmp = malloc(((unsigned int )numf1s * (unsigned int )numf2s) * sizeof(double ));
  bus = (double *)tmp;
  tmp___0 = malloc(((unsigned int )numf1s * (unsigned int )numf2s) * sizeof(double ));
  tds = (double *)tmp___0;
  if (0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Malloc problem in load_weights\n");
    exit(1);
  } else {
    if (0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Malloc problem in load_weights\n");
      exit(1);
    }
  }
  i = 0L;
  while (i < (long )numf1s) {
    i ++;
  }
  return;
}
}
void init_td(int start ) 
{ int i___0 ;
  int j___0 ;

  {
  i___0 = 0;
  while (i___0 < numf1s) {
    j___0 = start;
    while (j___0 < numf2s) {
      *(tds + (j___0 * (unsigned int )numf1s + i___0)) = 0.0;
      j___0 ++;
    }
    i___0 ++;
  }
  return;
}
}
void init_bu(int start ) 
{ int i___0 ;
  int j___0 ;
  double tmp ;

  {
  i___0 = 0;
  while (i___0 < numf1s) {
    j___0 = start;
    while (j___0 < numf2s) {
      tmp = sqrt((double )numf1s);
      *(bus + (j___0 * (unsigned int )numf1s + i___0)) = ((double )1 / (1.0 - d)) / tmp;
      j___0 ++;
    }
    i___0 ++;
  }
  return;
}
}
void load_train(char *trainfile , int mode , int objects ) 
{ int i___0 ;
  int fd ;
  char buffer[64] ;
  char *superbuffer ;
  unsigned char t ;
  int spot ;
  void *tmp ;

  {
  if (mode == 1) {
    spot = 0;
  } else {
    spot = 1;
  }
  fd = open((char const   *)trainfile, 0);
  if (fd == -1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error opening %s\n",
            trainfile);
    exit(1);
  }
  lwidth = 0;
  lheight = 0;
  read(fd, buffer, 8);
  read(fd, buffer, 4);
  i___0 = 0;
  while (i___0 < 4) {
    if ((int )buffer[i___0] != 32) {
      lwidth = (lwidth * 10 + (int )buffer[i___0]) - 48;
    }
    i___0 ++;
  }
  read(fd, buffer, 4);
  i___0 = 0;
  while (i___0 < 4) {
    if ((int )buffer[i___0] != 32) {
      lheight = (lheight * 10 + (int )buffer[i___0]) - 48;
    }
    i___0 ++;
  }
  if (mode == 1) {
    numinputs = lwidth * lheight;
    numf1s = numinputs;
    numf2s = objects + 1;
    init_globs(1);
    init_net();
  } else {
    if (lwidth * lheight != numf1s) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Dimensions of first image do not match");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" dimensions of second.\n");
      exit(1);
    }
  }
  tmp = malloc((unsigned int )(lwidth * lheight) * sizeof(char ));
  superbuffer = (char *)tmp;
  if ((unsigned int )superbuffer == (unsigned int )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Problems with malloc in loadimage()\n");
    exit(1);
  }
  read(fd, superbuffer, lwidth * lheight);
  i___0 = 0;
  while (i___0 < lheight * lwidth) {
    t = (unsigned char )*(superbuffer + i___0);
    *(f1_layer_I + (spot * (unsigned int )numf1s + i___0)) = (double )t;
    i___0 ++;
  }
  free((void *)superbuffer);
  return;
}
}
void sim_other_objects(int low , int high , int stop ) 
{ int i___0 ;
  int j___0 ;
  int noise1 ;
  double noise2 ;
  int tmp ;

  {
  if (high <= low) {
    return;
  }
  srand(10U);
  i___0 = low;
  while (i___0 < high) {
    j___0 = 0;
    while (j___0 < numf1s) {
      if (i___0 % low) {
        *(tds + (i___0 * (unsigned int )numf1s + j___0)) = *(tds + (0 * (unsigned int )numf1s + j___0));
        *(tds + (i___0 * (unsigned int )numf1s + j___0)) = *(bus + (0 * (unsigned int )numf1s + j___0));
      } else {
        *(tds + (i___0 * (unsigned int )numf1s + j___0)) = *(tds + (1 * (unsigned int )numf1s + j___0));
        *(tds + (i___0 * (unsigned int )numf1s + j___0)) = *(bus + (1 * (unsigned int )numf1s + j___0));
      }
      j___0 ++;
    }
    i___0 ++;
  }
  i___0 = low;
  while (i___0 < high) {
    j___0 = 0;
    while (j___0 < numf1s) {
      tmp = rand();
      noise1 = tmp & 65535;
      noise2 = (double )noise1 / (double )65535;
      *(tds + (i___0 * (unsigned int )numf1s + j___0)) += noise2;
      *(bus + (i___0 * (unsigned int )numf1s + j___0)) += noise2;
      j___0 ++;
    }
    i___0 ++;
  }
  return;
}
}
void setup_base_pattern(int spot ) 
{ int i___0 ;
  int j___0 ;
  double tmp ;

  {
  i___0 = 0;
  while (i___0 < numf1s) {
    j___0 = spot;
    while (j___0 < numf2s) {
      tmp = sqrt((double )numf1s);
      *(bus + (j___0 * (unsigned int )numf1s + i___0)) = (1.0 / tmp) / ((double )1 - d);
      *(tds + (j___0 * (unsigned int )numf1s + i___0)) = *(bus + (j___0 * (unsigned int )numf1s + i___0));
      j___0 ++;
    }
    i___0 ++;
  }
  return;
}
}
void scan_recognize(int startx , int starty , int endx , int endy , int stride ) 
{ int i___0 ;
  int j___0 ;
  int m ;
  int n ;
  long k ;
  long tmp ;

  {
  if (starty > (height - lheight) + 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Startx %d or Starty %d is out of range\n",
            startx, starty);
    exit(1);
  } else {
    if (startx > (width - lwidth) + 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Startx %d or Starty %d is out of range\n",
              startx, starty);
      exit(1);
    }
  }
  if (endy > (height - lheight) + 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"endx %d or endy %d is out of range\n",
            endx, endy);
    exit(1);
  } else {
    if (endx > (width - lwidth) + 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"endx %d or endy %d is out of range\n",
              endx, endy);
      exit(1);
    }
  }
  j___0 = starty;
  while (j___0 < endy) {
    i___0 = startx;
    while (i___0 < endx) {
      k = 0L;
      m = j___0;
      while (m < lheight + j___0) {
        n = i___0;
        while (n < lwidth + i___0) {
          tmp = k;
          k ++;
          *(f1_layer_I + (0 * (unsigned int )numf1s + tmp)) = (double )*(*(cimage + m) + n);
          n ++;
        }
        m ++;
      }
      pass_flag = 0;
      match();
      if (pass_flag == 1) {
        if (set_high[0] == 1) {
          highx[0] = i___0;
          highy[0] = j___0;
          set_high[0] = 0;
        }
        if (set_high[1] == 1) {
          highx[1] = i___0;
          highy[1] = j___0;
          set_high[1] = 0;
        }
      }
      i___0 += stride;
    }
    j___0 += stride;
  }
  return;
}
}
extern int ( /* missing proto */  strcmp)() ;
int main(int argc , char **argv ) 
{ int k ;
  int startx ;
  int starty ;
  int endx ;
  int endy ;
  int stride ;
  int objects ;
  int arg_index ;
  char *scanfile ;
  char *weightfile ;
  char *trainfile1 ;
  char *trainfile2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  scanfile = (char *)((void *)0);
  weightfile = (char *)((void *)0);
  trainfile1 = (char *)((void *)0);
  trainfile2 = (char *)((void *)0);
  if (argc < 2) {
    goto Usage;
  }
  if (argc == 2) {
    tmp___0 = strcmp(*(argv + 1), "-v");
    if (tmp___0 == 0) {
      goto Version;
    } else {
      tmp = strcmp(*(argv + 1), "-h");
      if (tmp == 0) {
        goto Usage;
      }
    }
  }
  stride = 0;
  startx = 0;
  starty = 0;
  endy = 0;
  endx = 0;
  objects = 0;
  arg_index = 1;
  while (arg_index < argc - 1) {
    tmp___10 = strcmp(*(argv + arg_index), "-scanfile");
    if (tmp___10 == 0) {
      scanfile = *(argv + (arg_index + 1));
    } else {
      tmp___9 = strcmp(*(argv + arg_index), "-weightfile");
      if (tmp___9 == 0) {
        weightfile = *(argv + (arg_index + 1));
      } else {
        tmp___8 = strcmp(*(argv + arg_index), "-trainfile1");
        if (tmp___8 == 0) {
          trainfile1 = *(argv + (arg_index + 1));
        } else {
          tmp___7 = strcmp(*(argv + arg_index), "-trainfile2");
          if (tmp___7 == 0) {
            trainfile2 = *(argv + (arg_index + 1));
          } else {
            tmp___6 = strcmp(*(argv + arg_index), "-startx");
            if (tmp___6 == 0) {
              startx = atoi((char const   *)*(argv + (arg_index + 1)));
            } else {
              tmp___5 = strcmp(*(argv + arg_index), "-starty");
              if (tmp___5 == 0) {
                starty = atoi((char const   *)*(argv + (arg_index + 1)));
              } else {
                tmp___4 = strcmp(*(argv + arg_index), "-endx");
                if (tmp___4 == 0) {
                  endx = atoi((char const   *)*(argv + (arg_index + 1)));
                } else {
                  tmp___3 = strcmp(*(argv + arg_index), "-endy");
                  if (tmp___3 == 0) {
                    endy = atoi((char const   *)*(argv + (arg_index + 1)));
                  } else {
                    tmp___2 = strcmp(*(argv + arg_index), "-stride");
                    if (tmp___2 == 0) {
                      stride = atoi((char const   *)*(argv + (arg_index + 1)));
                    } else {
                      tmp___1 = strcmp(*(argv + arg_index), "-objects");
                      if (tmp___1 == 0) {
                        objects = atoi((char const   *)*(argv + (arg_index + 1)));
                      } else {
                        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Unknown option -> %s\n",
                                *(argv + arg_index));
                        goto Usage;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    arg_index += 2;
  }
  if ((unsigned int )scanfile == (unsigned int )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Must specify input files\n");
    goto Usage;
  }
  if ((unsigned int )weightfile == (unsigned int )((void *)0)) {
    if ((unsigned int )trainfile1 == (unsigned int )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Must specify weightfile or trainfile1\n");
      goto Usage;
    }
  }
  if ((unsigned int )weightfile != (unsigned int )((void *)0)) {
    if ((unsigned int )trainfile1 != (unsigned int )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Cannot specify weightfile and trainfile1\n");
      goto Usage;
    }
  }
  loadimage(scanfile);
  if ((unsigned int )weightfile != (unsigned int )((void *)0)) {
    numpatterns = 1;
    if (objects == 0) {
      objects = numpatterns;
    }
    load_weights(weightfile);
    init_globs(0);
    init_net();
  } else {
    if ((unsigned int )trainfile2 != (unsigned int )((void *)0)) {
      numpatterns = 2;
      if (objects < numpatterns) {
        objects = numpatterns;
      }
      load_train(trainfile1, 1, objects);
      alloc_td_bu();
      init_td(0);
      init_bu(0);
      k = 0;
      resonant = k;
      while (! resonant) {
        train_match(0);
        k ++;
      }
      load_train(trainfile2, 2, objects);
      init_globs(2);
      init_td(1);
      init_bu(1);
      k = 0;
      resonant = k;
      while (! resonant) {
        train_match(1);
        k ++;
      }
      init_globs(0);
      init_td(objects);
      init_bu(objects);
      sim_other_objects(numpatterns, objects, numf2s);
      setup_base_pattern(objects);
    } else {
      numpatterns = 1;
      if (objects < numpatterns) {
        objects = numpatterns;
      }
      load_train(trainfile1, 1, objects);
      alloc_td_bu();
      init_td(0);
      init_bu(0);
      k = 0;
      resonant = k;
      while (! resonant) {
        train_match(0);
        k ++;
      }
      init_globs(0);
      init_td(1);
      init_bu(1);
      setup_base_pattern(1);
    }
  }
  if (endy == 0) {
    endy = height - lheight;
  }
  if (endx == 0) {
    endx = width - lwidth;
  }
  highest_confidence[0] = 0.0;
  highest_confidence[1] = 0.0;
  highx[0] = 0;
  highx[1] = 0;
  highy[0] = 0;
  highy[1] = 0;
  set_high[0] = 0;
  set_high[1] = 0;
  scan_recognize(startx, starty, endx, endy, stride);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Highest vigilance for 1 = %0.4f for object at X = %d, Y = %d\n",
          highest_confidence[0], highx[0], highy[0]);
  if (numpatterns == 2) {
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Highest vigilance for 2 = %0.4f for object at X = %d, Y = %d\n",
            highest_confidence[1], highx[1], highy[1]);
  }
  return (0);
  Usage: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: scanner [-startx <num>] [-starty <num>] [-endx <num>] [-endy <num>] [-stride <num>] -scanfile <filename> -trainfile1 <filename> [-trainfile2 <filename>]\n");
  exit(1);
  Version: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Version 1.00 \n");
  exit(1);
}
}
