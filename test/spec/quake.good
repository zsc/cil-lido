/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

typedef unsigned int size_t;
typedef long __off_t;
typedef long long __off64_t;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
struct _IO_FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15U * sizeof(int ) - 2U * sizeof(void *)] ;
};
struct options {
   int quiet ;
   int help ;
};
struct excitation {
   double dt ;
   double duration ;
   double t0 ;
};
struct damping {
   double zeta ;
   double consta ;
   double constb ;
   double freq ;
};
struct properties {
   double cp ;
   double cs ;
   double den ;
};
struct source {
   double dip ;
   double strike ;
   double rake ;
   double fault ;
   double xyz[3] ;
   double epixyz[3] ;
   int sourcenode ;
   int epicenternode ;
};
extern struct _IO_FILE *stdin ;
extern struct _IO_FILE *stdout ;
extern struct _IO_FILE *stderr ;
extern int fflush(FILE *__stream ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
extern double cos(double __x ) ;
extern double sin(double __x ) ;
extern double sqrt(double __x ) ;
char *progname  ;
struct options options  ;
FILE *packfile  ;
int ARCHnodes  ;
int ARCHpriv  ;
int ARCHmine  ;
int ARCHelems  ;
int ARCHglobalnodes  ;
int ARCHmesh_dim  ;
int ARCHglobalelems  ;
int ARCHcorners  ;
int ARCHsubdomains  ;
double ARCHduration  ;
int ARCHmatrixlen  ;
int ARCHcholeskylen  ;
int *ARCHglobalnode  ;
int *ARCHglobalelem  ;
double **ARCHcoord  ;
int **ARCHvertex  ;
int *ARCHmatrixcol  ;
int *ARCHmatrixindex  ;
void arch_init(int argc , char **argv , struct options *op ) ;
void mem_init(void) ;
void arch_readnodevector(double *v , int n ) ;
void slip(double *u , double *v , double *w ) ;
double distance(double *p1 , double *p2 ) ;
void centroid(double (*x)[3] , double *xc ) ;
double point2fault(double *x ) ;
void abe_matrix(double (*vertices)[3] , int *bv , struct properties *prop , double *Ce ) ;
void element_matrices(double (*vertices)[3] , struct properties *prop , double (*Ke)[12] ,
                      double *Me ) ;
void vv12x12(double *v1 , double *v2 , double *u ) ;
void mv12x12(double (*m)[12] , double *v ) ;
void smvp(int nodes , double ***A , int *Acol , int *Aindex , double **v , double **w ) ;
void smvp_opt(int nodes , double ***A , int *Acol , int *Aindex , double **v , double **w ) ;
double phi0(double t ) ;
double phi1(double t ) ;
double phi2(double t ) ;
int *nodekind  ;
double *nodekindf  ;
int *source_elms  ;
double **M  ;
double **C  ;
double **M23  ;
double **C23  ;
double **V23  ;
double **vel  ;
double ***disp  ;
double ***K  ;
struct source Src  ;
struct excitation Exc  ;
struct damping Damp  ;
int main(int argc , char **argv ) 
{ int i ;
  int j ;
  int k ;
  int ii ;
  int jj ;
  int kk ;
  int iter ;
  int timesteps ;
  int disptplus ;
  int dispt ;
  int disptminus ;
  int verticesonbnd ;
  int cor[4] ;
  int bv[4] ;
  int Step_stride ;
  double time ;
  double Ke[12][12] ;
  double Me[12] ;
  double Ce[12] ;
  double Mexv[12] ;
  double Cexv[12] ;
  double v[12] ;
  double alpha ;
  double c0[3] ;
  double d1 ;
  double d2 ;
  double bigdist1 ;
  double bigdist2 ;
  double xc[3] ;
  double uf[3] ;
  double vertices[4][3] ;
  struct properties prop ;
  double tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  arch_init(argc, argv, & options);
  mem_init();
  arch_readnodevector(nodekindf, ARCHnodes);
  if (! options.quiet) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Beginning simulation.\n",
            *(argv + 0));
  }
  Exc.dt = 0.0024;
  Exc.duration = ARCHduration;
  Exc.t0 = 0.6;
  timesteps = (int )(Exc.duration / 0.0024 + (double )1);
  Damp.zeta = 30.0;
  Damp.consta = 0.00533333;
  Damp.constb = 0.06666667;
  Damp.freq = 0.5;
  Src.strike = (111.0 * 3.141592653589793238) / 180.0;
  Src.dip = (44.0 * 3.141592653589793238) / 180.0;
  Src.rake = (70.0 * 3.141592653589793238) / 180.0;
  Src.fault = 29.640788;
  Src.xyz[0] = 32.264153;
  Src.xyz[1] = 23.814432;
  Src.xyz[2] = - 11.25;
  Src.epixyz[0] = Src.xyz[0];
  Src.epixyz[1] = Src.xyz[1];
  Src.epixyz[2] = 0.0;
  Src.sourcenode = -1;
  Src.epicenternode = -1;
  uf[2] = 0.0;
  uf[1] = uf[2];
  uf[0] = uf[1];
  slip(uf, & uf[1], & uf[2]);
  uf[0] *= Src.fault;
  uf[1] *= Src.fault;
  uf[2] *= Src.fault;
  prop.cp = 6.0;
  prop.cs = 3.2;
  prop.den = 2.0;
  Step_stride = 30;
  disptplus = 0;
  dispt = 1;
  disptminus = 2;
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"CASE SUMMARY\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Fault information\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  Orientation:  strike: %f\n",
          Src.strike);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"                   dip: %f\n",
          Src.dip);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"                  rake: %f\n",
          Src.rake);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"           dislocation: %f cm\n",
          Src.fault);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Hypocenter: (%f, %f, %f) Km\n",
          Src.xyz[0], Src.xyz[1], Src.xyz[2]);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Excitation characteristics\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"     Time step: %f sec\n",
          0.0024);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"      Duration: %f sec\n",
          Exc.duration);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"     Rise time: %f sec\n",
          0.6);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  fflush(stderr);
  i = 0;
  while (i < ARCHnodes) {
    *(nodekind + i) = (int )*(nodekindf + i);
    if (*(nodekind + i) == 3) {
      *(nodekind + i) = 1;
    }
    i ++;
  }
  bigdist1 = 1000000.0;
  bigdist2 = 1000000.0;
  i = 0;
  while (i < ARCHnodes) {
    c0[0] = *(*(ARCHcoord + i) + 0);
    c0[1] = *(*(ARCHcoord + i) + 1);
    c0[2] = *(*(ARCHcoord + i) + 2);
    d1 = distance(c0, Src.xyz);
    d2 = distance(c0, Src.epixyz);
    if (d1 < bigdist1) {
      bigdist1 = d1;
      Src.sourcenode = i;
    }
    if (d2 < bigdist2) {
      bigdist2 = d2;
      Src.epicenternode = i;
    }
    i ++;
  }
  if (Src.sourcenode != 0) {
    if (Src.sourcenode <= ARCHmine) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"The source is node %d at (%f  %f  %f)\n",
              *(ARCHglobalnode + Src.sourcenode), *(*(ARCHcoord + Src.sourcenode) + 0),
              *(*(ARCHcoord + Src.sourcenode) + 1), *(*(ARCHcoord + Src.sourcenode) + 2));
      fflush(stderr);
    }
  }
  if (Src.epicenternode != 0) {
    if (Src.epicenternode <= ARCHmine) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"The epicenter is node %d at (%f  %f  %f)\n",
              *(ARCHglobalnode + Src.epicenternode), *(*(ARCHcoord + Src.epicenternode) + 0),
              *(*(ARCHcoord + Src.epicenternode) + 1), *(*(ARCHcoord + Src.epicenternode) + 2));
      fflush(stderr);
    }
  }
  if (Src.sourcenode != 0) {
    i = 0;
    while (i < ARCHelems) {
      j = 0;
      while (j < 4) {
        cor[j] = *(*(ARCHvertex + i) + j);
        j ++;
      }
      if (cor[0] == Src.sourcenode) {
        goto _L;
      } else {
        if (cor[1] == Src.sourcenode) {
          goto _L;
        } else {
          if (cor[2] == Src.sourcenode) {
            goto _L;
          } else {
            if (cor[3] == Src.sourcenode) {
              _L: /* CIL Label */ 
              j = 0;
              while (j < 4) {
                k = 0;
                while (k < 3) {
                  vertices[j][k] = *(*(ARCHcoord + cor[j]) + k);
                  k ++;
                }
                j ++;
              }
              centroid(vertices, xc);
              *(source_elms + i) = 2;
              tmp = point2fault(xc);
              if (tmp >= (double )0) {
                *(source_elms + i) = 3;
              }
            }
          }
        }
      }
      i ++;
    }
  }
  i = 0;
  while (i < ARCHelems) {
    j = 0;
    while (j < 12) {
      Me[j] = 0.0;
      Ce[j] = 0.0;
      v[j] = 0.0;
      k = 0;
      while (k < 12) {
        Ke[j][k] = 0.0;
        k ++;
      }
      j ++;
    }
    j = 0;
    while (j < 4) {
      cor[j] = *(*(ARCHvertex + i) + j);
      j ++;
    }
    verticesonbnd = 0;
    j = 0;
    while (j < 4) {
      if (*(nodekind + cor[j]) != 1) {
        tmp___0 = verticesonbnd;
        verticesonbnd ++;
        bv[tmp___0] = j;
      }
      j ++;
    }
    if (verticesonbnd == 3) {
      j = 0;
      while (j < 3) {
        k = 0;
        while (k < 3) {
          vertices[j][k] = *(*(ARCHcoord + cor[bv[j]]) + k);
          k ++;
        }
        j ++;
      }
      abe_matrix(vertices, bv, & prop, Ce);
    }
    j = 0;
    while (j < 4) {
      k = 0;
      while (k < 3) {
        vertices[j][k] = *(*(ARCHcoord + cor[j]) + k);
        k ++;
      }
      j ++;
    }
    element_matrices(vertices, & prop, Ke, Me);
    centroid(vertices, xc);
    if (xc[2] < - 11.5) {
      alpha = ((2.0 * 30.0) / 100.0) * ((2.0 * 3.141592653589793238) * 0.5);
    } else {
      alpha = (((4.0 * 3.141592653589793238) * 0.00533333) * 0.95) / (prop.cs + 0.06666667);
    }
    j = 0;
    while (j < 12) {
      Ce[j] += alpha * Me[j];
      j ++;
    }
    if (*(source_elms + i) == 2) {
      goto _L___0;
    } else {
      if (*(source_elms + i) == 3) {
        _L___0: /* CIL Label */ 
        j = 0;
        while (j < 4) {
          if (cor[j] == Src.sourcenode) {
            v[3 * j] = uf[0];
            v[3 * j + 1] = uf[1];
            v[3 * j + 2] = uf[2];
          } else {
            v[3 * j] = (double )0;
            v[3 * j + 1] = (double )0;
            v[3 * j + 2] = (double )0;
          }
          j ++;
        }
        vv12x12(Me, v, Mexv);
        vv12x12(Ce, v, Cexv);
        mv12x12(Ke, v);
        if (*(source_elms + i) == 3) {
          j = 0;
          while (j < 12) {
            v[j] = - v[j];
            Mexv[j] = - Mexv[j];
            Cexv[j] = - Cexv[j];
            j ++;
          }
        }
        j = 0;
        while (j < 4) {
          *(*(V23 + *(*(ARCHvertex + i) + j)) + 0) += v[j * 3];
          *(*(V23 + *(*(ARCHvertex + i) + j)) + 1) += v[j * 3 + 1];
          *(*(V23 + *(*(ARCHvertex + i) + j)) + 2) += v[j * 3 + 2];
          *(*(M23 + *(*(ARCHvertex + i) + j)) + 0) += Mexv[j * 3];
          *(*(M23 + *(*(ARCHvertex + i) + j)) + 1) += Mexv[j * 3 + 1];
          *(*(M23 + *(*(ARCHvertex + i) + j)) + 2) += Mexv[j * 3 + 2];
          *(*(C23 + *(*(ARCHvertex + i) + j)) + 0) += Cexv[j * 3];
          *(*(C23 + *(*(ARCHvertex + i) + j)) + 1) += Cexv[j * 3 + 1];
          *(*(C23 + *(*(ARCHvertex + i) + j)) + 2) += Cexv[j * 3 + 2];
          j ++;
        }
      }
    }
    j = 0;
    while (j < 4) {
      *(*(M + *(*(ARCHvertex + i) + j)) + 0) += Me[j * 3];
      *(*(M + *(*(ARCHvertex + i) + j)) + 1) += Me[j * 3 + 1];
      *(*(M + *(*(ARCHvertex + i) + j)) + 2) += Me[j * 3 + 2];
      *(*(C + *(*(ARCHvertex + i) + j)) + 0) += Ce[j * 3];
      *(*(C + *(*(ARCHvertex + i) + j)) + 1) += Ce[j * 3 + 1];
      *(*(C + *(*(ARCHvertex + i) + j)) + 2) += Ce[j * 3 + 2];
      k = 0;
      while (k < 4) {
        if (*(*(ARCHvertex + i) + j) <= *(*(ARCHvertex + i) + k)) {
          kk = *(ARCHmatrixindex + *(*(ARCHvertex + i) + j));
          while (*(ARCHmatrixcol + kk) != *(*(ARCHvertex + i) + k)) {
            kk ++;
            if (kk >= *(ARCHmatrixindex + (*(*(ARCHvertex + i) + k) + 1))) {
              printf((char const   * __restrict  )"K indexing error!!! %d %d\n", *(*(ARCHvertex + i) + j),
                     *(*(ARCHvertex + i) + k));
              exit(1);
            }
          }
          ii = 0;
          while (ii < 3) {
            jj = 0;
            while (jj < 3) {
              *(*(*(K + kk) + ii) + jj) += Ke[j * 3 + ii][k * 3 + jj];
              jj ++;
            }
            ii ++;
          }
        }
        k ++;
      }
      j ++;
    }
    i ++;
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  iter = 1;
  while (iter <= timesteps) {
    i = 0;
    while (i < ARCHnodes) {
      j = 0;
      while (j < 3) {
        *(*(*(disp + disptplus) + i) + j) = 0.0;
        j ++;
      }
      i ++;
    }
    smvp(ARCHnodes, K, ARCHmatrixcol, ARCHmatrixindex, *(disp + dispt), *(disp + disptplus));
    time = (double )iter * 0.0024;
    tmp___3 = phi0(time);
    tmp___2 = phi1(time);
    tmp___1 = phi2(time);
    i = 0;
    while (i < ARCHnodes) {
      j = 0;
      while (j < 3) {
        *(*(*(disp + disptplus) + i) + j) = (*(*(*(disp + disptplus) + i) + j) * (- 0.0024 * 0.0024) + (((2.0 * *(*(M + i) + j)) * *(*(*(disp + dispt) + i) + j) - (*(*(M + i) + j) - (0.0024 / 2.0) * *(*(C + i) + j)) * *(*(*(disp + disptminus) + i) + j)) - (0.0024 * 0.0024) * (((*(*(M23 + i) + j) * tmp___1) / 2.0 + (*(*(C23 + i) + j) * tmp___2) / 2.0) + (*(*(V23 + i) + j) * tmp___3) / 2.0))) / (*(*(M + i) + j) + (0.0024 / 2.0) * *(*(C + i) + j));
        j ++;
      }
      i ++;
    }
    if (iter % Step_stride == 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Time step %d\n",
              iter);
      if (Src.sourcenode <= ARCHmine) {
        printf((char const   * __restrict  )"%d: %.2e %.2e %.2e\n", *(ARCHglobalnode + Src.sourcenode),
               *(*(*(disp + disptplus) + Src.sourcenode) + 0), *(*(*(disp + disptplus) + Src.sourcenode) + 1),
               *(*(*(disp + disptplus) + Src.sourcenode) + 2));
      }
      if (Src.epicenternode <= ARCHmine) {
        printf((char const   * __restrict  )"%d: %.2e %.2e %.2e\n", *(ARCHglobalnode + Src.epicenternode),
               *(*(*(disp + disptplus) + Src.epicenternode) + 0), *(*(*(disp + disptplus) + Src.epicenternode) + 1),
               *(*(*(disp + disptplus) + Src.epicenternode) + 2));
      }
      fflush(stdout);
    }
    i = disptminus;
    disptminus = dispt;
    dispt = disptplus;
    disptplus = i;
    iter ++;
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %d nodes %d elems %d timesteps\n",
          progname, ARCHglobalnodes, ARCHglobalelems, timesteps);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  fflush(stderr);
  if (! options.quiet) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Done. Terminating the simulation.\n",
            progname);
  }
  return (0);
}
}
void shape_ders(double (*ds)[4] ) 
{ 

  {
  (*(ds + 0))[0] = (double )-1;
  (*(ds + 1))[0] = (double )-1;
  (*(ds + 2))[0] = (double )-1;
  (*(ds + 0))[1] = (double )1;
  (*(ds + 1))[1] = (double )0;
  (*(ds + 2))[1] = (double )0;
  (*(ds + 0))[2] = (double )0;
  (*(ds + 1))[2] = (double )1;
  (*(ds + 2))[2] = (double )0;
  (*(ds + 0))[3] = (double )0;
  (*(ds + 1))[3] = (double )0;
  (*(ds + 2))[3] = (double )1;
  return;
}
}
void get_Enu(struct properties *prop , double *E , double *nu ) 
{ double ratio ;

  {
  ratio = (prop->cp / prop->cs) * (prop->cp / prop->cs);
  *nu = (0.5 * (ratio - 2.0)) / (ratio - 1.0);
  *E = (((2.0 * prop->den) * prop->cs) * prop->cs) * (1.0 + *nu);
  return;
}
}
void inv_J(double (*a)[3] , double *det ) 
{ double d1 ;
  double c[3][3] ;
  int i ;
  int j ;

  {
  c[0][0] = (*(a + 1))[1] * (*(a + 2))[2] - (*(a + 2))[1] * (*(a + 1))[2];
  c[0][1] = (*(a + 0))[2] * (*(a + 2))[1] - (*(a + 0))[1] * (*(a + 2))[2];
  c[0][2] = (*(a + 0))[1] * (*(a + 1))[2] - (*(a + 0))[2] * (*(a + 1))[1];
  c[1][0] = (*(a + 1))[2] * (*(a + 2))[0] - (*(a + 1))[0] * (*(a + 2))[2];
  c[1][1] = (*(a + 0))[0] * (*(a + 2))[2] - (*(a + 0))[2] * (*(a + 2))[0];
  c[1][2] = (*(a + 0))[2] * (*(a + 1))[0] - (*(a + 0))[0] * (*(a + 1))[2];
  c[2][0] = (*(a + 1))[0] * (*(a + 2))[1] - (*(a + 1))[1] * (*(a + 2))[0];
  c[2][1] = (*(a + 0))[1] * (*(a + 2))[0] - (*(a + 0))[0] * (*(a + 2))[1];
  c[2][2] = (*(a + 0))[0] * (*(a + 1))[1] - (*(a + 0))[1] * (*(a + 1))[0];
  *det = ((*(a + 0))[0] * c[0][0] + (*(a + 0))[1] * c[1][0]) + (*(a + 0))[2] * c[2][0];
  d1 = 1.0 / *det;
  i = 0;
  while (i < 3) {
    j = 0;
    while (j < 3) {
      (*(a + i))[j] = c[i][j] * d1;
      j ++;
    }
    i ++;
  }
  return;
}
}
void element_matrices(double (*vertices)[3] , struct properties *prop , double (*Ke)[12] ,
                      double *Me ) 
{ double ds[3][4] ;
  double sum[3] ;
  double jacobian[3][3] ;
  double det ;
  double volume ;
  double E ;
  double nu ;
  double c1 ;
  double c2 ;
  double c3 ;
  double tt ;
  double ts ;
  int i ;
  int j ;
  int m ;
  int n ;
  int row ;
  int column ;

  {
  shape_ders(ds);
  i = 0;
  while (i < 3) {
    j = 0;
    while (j < 3) {
      sum[0] = 0.0;
      m = 0;
      while (m < 4) {
        sum[0] += ds[i][m] * (*(vertices + m))[j];
        m ++;
      }
      jacobian[j][i] = sum[0];
      j ++;
    }
    i ++;
  }
  inv_J(jacobian, & det);
  m = 0;
  while (m < 4) {
    i = 0;
    while (i < 3) {
      sum[i] = 0.0;
      j = 0;
      while (j < 3) {
        sum[i] += jacobian[j][i] * ds[j][m];
        j ++;
      }
      i ++;
    }
    i = 0;
    while (i < 3) {
      ds[i][m] = sum[i];
      i ++;
    }
    m ++;
  }
  volume = det / 6.0;
  if (volume <= (double )0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: Element volume = %f !\n",
            volume);
  }
  get_Enu(prop, & E, & nu);
  c1 = (E / ((2.0 * (nu + 1.0)) * (1.0 - nu * 2.0))) * volume;
  c2 = ((E * nu) / ((nu + 1.0) * (1.0 - nu * 2.0))) * volume;
  c3 = (E / ((nu + 1.0) * 2.0)) * volume;
  row = -1;
  m = 0;
  while (m < 4) {
    i = 0;
    while (i < 3) {
      row ++;
      column = -1;
      n = 0;
      while (n <= m) {
        j = 0;
        while (j < 3) {
          column ++;
          ts = ds[i][m] * ds[j][n];
          if (i == j) {
            ts *= c1;
            tt = ((ds[0][m] * ds[0][n] + ds[1][m] * ds[1][n]) + ds[2][m] * ds[2][n]) * c3;
          } else {
            if (m == n) {
              ts *= c1;
              tt = (double )0;
            } else {
              ts *= c2;
              tt = (ds[j][m] * ds[i][n]) * c3;
            }
          }
          (*(Ke + row))[column] = ((*(Ke + row))[column] + ts) + tt;
          j ++;
        }
        n ++;
      }
      i ++;
    }
    m ++;
  }
  tt = (prop->den * volume) / 4.0;
  i = 0;
  while (i < 12) {
    *(Me + i) = tt;
    i ++;
  }
  i = 0;
  while (i < 12) {
    j = 0;
    while (j <= i) {
      (*(Ke + j))[i] = (*(Ke + i))[j];
      j ++;
    }
    i ++;
  }
  return;
}
}
double area_triangle(double (*vertices)[3] ) 
{ double a ;
  double b ;
  double c ;
  double x2 ;
  double y2 ;
  double z2 ;
  double p ;
  double area ;

  {
  x2 = ((*(vertices + 0))[0] - (*(vertices + 1))[0]) * ((*(vertices + 0))[0] - (*(vertices + 1))[0]);
  y2 = ((*(vertices + 0))[1] - (*(vertices + 1))[1]) * ((*(vertices + 0))[1] - (*(vertices + 1))[1]);
  z2 = ((*(vertices + 0))[2] - (*(vertices + 1))[2]) * ((*(vertices + 0))[2] - (*(vertices + 1))[2]);
  a = sqrt((x2 + y2) + z2);
  x2 = ((*(vertices + 2))[0] - (*(vertices + 1))[0]) * ((*(vertices + 2))[0] - (*(vertices + 1))[0]);
  y2 = ((*(vertices + 2))[1] - (*(vertices + 1))[1]) * ((*(vertices + 2))[1] - (*(vertices + 1))[1]);
  z2 = ((*(vertices + 2))[2] - (*(vertices + 1))[2]) * ((*(vertices + 2))[2] - (*(vertices + 1))[2]);
  b = sqrt((x2 + y2) + z2);
  x2 = ((*(vertices + 0))[0] - (*(vertices + 2))[0]) * ((*(vertices + 0))[0] - (*(vertices + 2))[0]);
  y2 = ((*(vertices + 0))[1] - (*(vertices + 2))[1]) * ((*(vertices + 0))[1] - (*(vertices + 2))[1]);
  z2 = ((*(vertices + 0))[2] - (*(vertices + 2))[2]) * ((*(vertices + 0))[2] - (*(vertices + 2))[2]);
  c = sqrt((x2 + y2) + z2);
  p = ((a + b) + c) / 2.0;
  area = sqrt(((p * (p - a)) * (p - b)) * (p - c));
  return (area);
}
}
void abe_matrix(double (*vertices)[3] , int *bv , struct properties *prop , double *Ce ) 
{ int i ;
  int j ;
  double area ;

  {
  area = area_triangle(vertices);
  i = 0;
  while (i < 3) {
    j = 3 * *(bv + i);
    *(Ce + j) += ((prop->cs * prop->den) * area) / 3.0;
    *(Ce + (j + 1)) += ((prop->cs * prop->den) * area) / 3.0;
    *(Ce + (j + 2)) += ((prop->cp * prop->den) * area) / 3.0;
    i ++;
  }
  return;
}
}
double phi0(double t ) 
{ double value ;
  double tmp ;

  {
  if (t <= 0.6) {
    tmp = sin(((2.0 * 3.141592653589793238) * t) / 0.6);
    value = (0.5 / 3.141592653589793238) * (((2.0 * 3.141592653589793238) * t) / 0.6 - tmp);
    return (value);
  } else {
    return (1.0);
  }
}
}
double phi1(double t ) 
{ double value ;
  double tmp ;

  {
  if (t <= 0.6) {
    tmp = cos(((2.0 * 3.141592653589793238) * t) / 0.6);
    value = (1.0 - tmp) / 0.6;
    return (value);
  } else {
    return (0.0);
  }
}
}
double phi2(double t ) 
{ double value ;
  double tmp ;

  {
  if (t <= 0.6) {
    tmp = sin(((2.0 * 3.141592653589793238) * t) / 0.6);
    value = (((2.0 * 3.141592653589793238) / 0.6) / 0.6) * tmp;
    return (value);
  } else {
    return (0.0);
  }
}
}
void slip(double *u , double *v , double *w ) 
{ double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;

  {
  *w = 0.0;
  *v = *w;
  *u = *v;
  tmp = cos(Src.rake);
  tmp___0 = sin(Src.strike);
  tmp___1 = sin(Src.rake);
  tmp___2 = cos(Src.strike);
  tmp___3 = cos(Src.dip);
  *u = tmp * tmp___0 - (tmp___1 * tmp___2) * tmp___3;
  tmp___4 = cos(Src.rake);
  tmp___5 = cos(Src.strike);
  tmp___6 = sin(Src.rake);
  tmp___7 = sin(Src.strike);
  tmp___8 = cos(Src.dip);
  *v = tmp___4 * tmp___5 + (tmp___6 * tmp___7) * tmp___8;
  tmp___9 = sin(Src.rake);
  tmp___10 = sin(Src.dip);
  *w = tmp___9 * tmp___10;
  return;
}
}
double distance(double *p1 , double *p2 ) 
{ 

  {
  return (((*(p1 + 0) - *(p2 + 0)) * (*(p1 + 0) - *(p2 + 0)) + (*(p1 + 1) - *(p2 + 1)) * (*(p1 + 1) - *(p2 + 1))) + (*(p1 + 2) - *(p2 + 2)) * (*(p1 + 2) - *(p2 + 2)));
}
}
void centroid(double (*x)[3] , double *xc ) 
{ int i ;

  {
  i = 0;
  while (i < 3) {
    *(xc + i) = ((((*(x + 0))[i] + (*(x + 1))[i]) + (*(x + 2))[i]) + (*(x + 3))[i]) / 4.0;
    i ++;
  }
  return;
}
}
double point2fault(double *x ) 
{ double nx ;
  double ny ;
  double nz ;
  double d0 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  tmp = cos(Src.strike);
  tmp___0 = sin(Src.dip);
  nx = tmp * tmp___0;
  tmp___1 = sin(Src.strike);
  tmp___2 = sin(Src.dip);
  ny = - tmp___1 * tmp___2;
  nz = cos(Src.dip);
  d0 = - ((nx * Src.xyz[0] + ny * Src.xyz[1]) + nz * Src.xyz[2]);
  return (((nx * *(x + 0) + ny * *(x + 1)) + nz * *(x + 2)) + d0);
}
}
void mv12x12(double (*m)[12] , double *v ) 
{ int i ;
  int j ;
  double u[12] ;

  {
  i = 0;
  while (i < 12) {
    u[i] = (double )0;
    j = 0;
    while (j < 12) {
      u[i] += (*(m + i))[j] * *(v + j);
      j ++;
    }
    i ++;
  }
  i = 0;
  while (i < 12) {
    *(v + i) = u[i];
    i ++;
  }
  return;
}
}
void vv12x12(double *v1 , double *v2 , double *u ) 
{ int i ;

  {
  i = 0;
  while (i < 12) {
    *(u + i) = *(v1 + i) * *(v2 + i);
    i ++;
  }
  return;
}
}
void arch_bail(void) 
{ 

  {
  exit(0);
}
}
void arch_info(void) 
{ 

  {
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"You are running an Archimedes finite element simulation called %s.\n\n",
         progname);
  printf((char const   * __restrict  )"The command syntax is:\n\n");
  printf((char const   * __restrict  )"%s [-Qh] < packfile\n\n", progname);
  printf((char const   * __restrict  )"Command line options:\n\n");
  printf((char const   * __restrict  )"    -Q  Quietly suppress all explanation of what this program is doing\n");
  printf((char const   * __restrict  )"        unless an error occurs.\n");
  printf((char const   * __restrict  )"    -h  Print this message and exit.\n");
  return;
}
}
void arch_parsecommandline(int argc , char **argv , struct options *op ) 
{ int i ;
  int j ;

  {
  op->quiet = 0;
  op->help = 0;
  i = 1;
  while (i < argc) {
    if ((int )*(*(argv + i) + 0) == 45) {
      j = 1;
      while ((int )*(*(argv + i) + j) != 0) {
        if ((int )*(*(argv + i) + j) == 81) {
          op->quiet = 1;
        }
        if ((int )*(*(argv + i) + j) == 104) {
          op->help = 1;
        } else {
          if ((int )*(*(argv + i) + j) == 72) {
            op->help = 1;
          }
        }
        j ++;
      }
    }
    i ++;
  }
  if (op->help) {
    arch_info();
    exit(0);
  }
  return;
}
}
void arch_readnodevector(double *v , int n ) 
{ int i ;
  int type ;
  int attributes ;

  {
  fscanf((FILE * __restrict  )packfile, (char const   * __restrict  )"%d %d\n", & type,
         & attributes);
  if (type != 2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"READNODEVECTOR: unexpected data type\n");
    arch_bail();
  }
  if (attributes != 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"READNODEVECTOR: unexpected number of attributes\n");
    arch_bail();
  }
  i = 0;
  while (i < n) {
    fscanf((FILE * __restrict  )packfile, (char const   * __restrict  )"%lf", v + i);
    i ++;
  }
  return;
}
}
void arch_readelemvector(double *v , int n ) 
{ int i ;
  int type ;
  int attributes ;

  {
  fscanf((FILE * __restrict  )packfile, (char const   * __restrict  )"%d %d\n", & type,
         & attributes);
  if (type != 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"READELEMVECTOR: unexpected data type\n");
    arch_bail();
  }
  if (attributes != 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"READELEMVECTOR: unexpected number of attributes\n");
    arch_bail();
  }
  i = 0;
  while (i < n) {
    fscanf((FILE * __restrict  )packfile, (char const   * __restrict  )"%lf", v + i);
    i ++;
  }
  return;
}
}
void arch_readdouble(double *v ) 
{ int type ;
  int attributes ;

  {
  fscanf((FILE * __restrict  )packfile, (char const   * __restrict  )"%d %d\n", & type,
         & attributes);
  if (type != 3) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"READDOUBLE: unexpected data type\n");
    arch_bail();
  }
  if (attributes != 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"READDOUBLE: unexpected number of attributes\n");
    arch_bail();
  }
  fscanf((FILE * __restrict  )packfile, (char const   * __restrict  )"%lf", v + 0);
  return;
}
}
void readpackfile(FILE *packfile___0 , struct options *op ) 
{ int oldrow ;
  int newrow ;
  int i ;
  int j ;
  int temp1 ;
  int temp2 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  fscanf((FILE * __restrict  )packfile___0, (char const   * __restrict  )"%d", & ARCHglobalnodes);
  fscanf((FILE * __restrict  )packfile___0, (char const   * __restrict  )"%d", & ARCHmesh_dim);
  fscanf((FILE * __restrict  )packfile___0, (char const   * __restrict  )"%d", & ARCHglobalelems);
  fscanf((FILE * __restrict  )packfile___0, (char const   * __restrict  )"%d", & ARCHcorners);
  fscanf((FILE * __restrict  )packfile___0, (char const   * __restrict  )"%d", & ARCHsubdomains);
  fscanf((FILE * __restrict  )packfile___0, (char const   * __restrict  )"%lf", & ARCHduration);
  if (ARCHsubdomains != 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: too many subdomains(%d), rerun slice using -s1\n",
            progname, ARCHsubdomains);
    arch_bail();
  }
  if (! op->quiet) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Reading nodes.\n",
            progname);
  }
  fscanf((FILE * __restrict  )packfile___0, (char const   * __restrict  )"%d %d %d",
         & ARCHnodes, & ARCHmine, & ARCHpriv);
  tmp = malloc((unsigned int )ARCHnodes * sizeof(int ));
  ARCHglobalnode = (int *)tmp;
  if ((unsigned int )ARCHglobalnode == (unsigned int )((int *)((void *)0))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for ARCHglobalnode\n");
    fflush(stderr);
    exit(0);
  }
  tmp___0 = malloc((unsigned int )ARCHnodes * sizeof(double *));
  ARCHcoord = (double **)tmp___0;
  i = 0;
  while (i < ARCHnodes) {
    tmp___1 = malloc(3U * sizeof(double ));
    *(ARCHcoord + i) = (double *)tmp___1;
    i ++;
  }
  i = 0;
  while (i < ARCHnodes) {
    fscanf((FILE * __restrict  )packfile___0, (char const   * __restrict  )"%d", ARCHglobalnode + i);
    j = 0;
    while (j < ARCHmesh_dim) {
      fscanf((FILE * __restrict  )packfile___0, (char const   * __restrict  )"%lf",
             *(ARCHcoord + i) + j);
      j ++;
    }
    i ++;
  }
  if (! op->quiet) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Reading elements.\n",
            progname);
  }
  fscanf((FILE * __restrict  )packfile___0, (char const   * __restrict  )"%d", & ARCHelems);
  tmp___2 = malloc((unsigned int )ARCHelems * sizeof(int ));
  ARCHglobalelem = (int *)tmp___2;
  if ((unsigned int )ARCHglobalelem == (unsigned int )((int *)((void *)0))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for ARCHglobalelem\n");
    fflush(stderr);
    exit(0);
  }
  tmp___3 = malloc((unsigned int )ARCHelems * sizeof(int *));
  ARCHvertex = (int **)tmp___3;
  i = 0;
  while (i < ARCHelems) {
    tmp___4 = malloc(4U * sizeof(int ));
    *(ARCHvertex + i) = (int *)tmp___4;
    i ++;
  }
  i = 0;
  while (i < ARCHelems) {
    fscanf((FILE * __restrict  )packfile___0, (char const   * __restrict  )"%d", ARCHglobalelem + i);
    j = 0;
    while (j < ARCHcorners) {
      fscanf((FILE * __restrict  )packfile___0, (char const   * __restrict  )"%d",
             *(ARCHvertex + i) + j);
      j ++;
    }
    i ++;
  }
  if (! op->quiet) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Reading sparse matrix structure.\n",
            progname);
  }
  fscanf((FILE * __restrict  )packfile___0, (char const   * __restrict  )"%d %d",
         & ARCHmatrixlen, & ARCHcholeskylen);
  tmp___5 = malloc((unsigned int )(ARCHmatrixlen + 1) * sizeof(int ));
  ARCHmatrixcol = (int *)tmp___5;
  if ((unsigned int )ARCHmatrixcol == (unsigned int )((int *)((void *)0))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for ARCHmatrixcol\n");
    fflush(stderr);
    exit(0);
  }
  tmp___6 = malloc((unsigned int )(ARCHnodes + 1) * sizeof(int ));
  ARCHmatrixindex = (int *)tmp___6;
  if ((unsigned int )ARCHmatrixindex == (unsigned int )((int *)((void *)0))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for ARCHmatrixindex\n");
    fflush(stderr);
    exit(0);
  }
  oldrow = -1;
  i = 0;
  while (i < ARCHmatrixlen) {
    fscanf((FILE * __restrict  )packfile___0, (char const   * __restrict  )"%d", & newrow);
    fscanf((FILE * __restrict  )packfile___0, (char const   * __restrict  )"%d", ARCHmatrixcol + i);
    while (oldrow < newrow) {
      if (oldrow + 1 >= ARCHnodes + 1) {
        printf((char const   * __restrict  )"%s: error: (1)idx buffer too small (%d >= %d)\n",
               progname, oldrow + 1, ARCHnodes + 1);
        arch_bail();
      }
      oldrow ++;
      *(ARCHmatrixindex + oldrow) = i;
    }
    i ++;
  }
  while (oldrow < ARCHnodes) {
    oldrow ++;
    *(ARCHmatrixindex + oldrow) = ARCHmatrixlen;
  }
  fscanf((FILE * __restrict  )packfile___0, (char const   * __restrict  )"%d %d",
         & temp1, & temp2);
  return;
}
}
void arch_init(int argc , char **argv , struct options *op ) 
{ 

  {
  progname = *(argv + 0);
  arch_parsecommandline(argc, argv, op);
  packfile = stdin;
  readpackfile(packfile, op);
  return;
}
}
void smvp(int nodes , double ***A , int *Acol , int *Aindex , double **v , double **w ) 
{ int i ;
  int Anext ;
  int Alast ;
  int col ;
  double sum0 ;
  double sum1 ;
  double sum2 ;

  {
  i = 0;
  while (i < nodes) {
    Anext = *(Aindex + i);
    Alast = *(Aindex + (i + 1));
    sum0 = (*(*(*(A + Anext) + 0) + 0) * *(*(v + i) + 0) + *(*(*(A + Anext) + 0) + 1) * *(*(v + i) + 1)) + *(*(*(A + Anext) + 0) + 2) * *(*(v + i) + 2);
    sum1 = (*(*(*(A + Anext) + 1) + 0) * *(*(v + i) + 0) + *(*(*(A + Anext) + 1) + 1) * *(*(v + i) + 1)) + *(*(*(A + Anext) + 1) + 2) * *(*(v + i) + 2);
    sum2 = (*(*(*(A + Anext) + 2) + 0) * *(*(v + i) + 0) + *(*(*(A + Anext) + 2) + 1) * *(*(v + i) + 1)) + *(*(*(A + Anext) + 2) + 2) * *(*(v + i) + 2);
    Anext ++;
    while (Anext < Alast) {
      col = *(Acol + Anext);
      sum0 += (*(*(*(A + Anext) + 0) + 0) * *(*(v + col) + 0) + *(*(*(A + Anext) + 0) + 1) * *(*(v + col) + 1)) + *(*(*(A + Anext) + 0) + 2) * *(*(v + col) + 2);
      sum1 += (*(*(*(A + Anext) + 1) + 0) * *(*(v + col) + 0) + *(*(*(A + Anext) + 1) + 1) * *(*(v + col) + 1)) + *(*(*(A + Anext) + 1) + 2) * *(*(v + col) + 2);
      sum2 += (*(*(*(A + Anext) + 2) + 0) * *(*(v + col) + 0) + *(*(*(A + Anext) + 2) + 1) * *(*(v + col) + 1)) + *(*(*(A + Anext) + 2) + 2) * *(*(v + col) + 2);
      *(*(w + col) + 0) += (*(*(*(A + Anext) + 0) + 0) * *(*(v + i) + 0) + *(*(*(A + Anext) + 1) + 0) * *(*(v + i) + 1)) + *(*(*(A + Anext) + 2) + 0) * *(*(v + i) + 2);
      *(*(w + col) + 1) += (*(*(*(A + Anext) + 0) + 1) * *(*(v + i) + 0) + *(*(*(A + Anext) + 1) + 1) * *(*(v + i) + 1)) + *(*(*(A + Anext) + 2) + 1) * *(*(v + i) + 2);
      *(*(w + col) + 2) += (*(*(*(A + Anext) + 0) + 2) * *(*(v + i) + 0) + *(*(*(A + Anext) + 1) + 2) * *(*(v + i) + 1)) + *(*(*(A + Anext) + 2) + 2) * *(*(v + i) + 2);
      Anext ++;
    }
    *(*(w + i) + 0) += sum0;
    *(*(w + i) + 1) += sum1;
    *(*(w + i) + 2) += sum2;
    i ++;
  }
  return;
}
}
void smvp_opt(int nodes , double ***A , int *Acol , int *Aindex , double **v , double **w ) 
{ int i ;
  int Anext ;
  int Alast ;
  double vi0 ;
  double vi1 ;
  double vi2 ;
  double sum0 ;
  double sum1 ;
  double sum2 ;
  double value ;
  double vcol0 ;
  double vcol1 ;
  double vcol2 ;
  double wcol0 ;
  double wcol1 ;
  double wcol2 ;
  int col ;

  {
  i = 0;
  while (i < nodes) {
    *(*(w + i) + 0) = 0.0;
    *(*(w + i) + 1) = 0.0;
    *(*(w + i) + 2) = 0.0;
    i ++;
  }
  i = 0;
  while (i < nodes) {
    vi0 = *(*(v + i) + 0);
    vi1 = *(*(v + i) + 1);
    vi2 = *(*(v + i) + 2);
    Anext = *(Aindex + i);
    Alast = *(Aindex + (i + 1));
    sum0 = ((*(*(w + i) + 0) + *(*(*(A + Anext) + 0) + 0) * vi0) + *(*(*(A + Anext) + 0) + 1) * vi1) + *(*(*(A + Anext) + 0) + 2) * vi2;
    sum1 = ((*(*(w + i) + 1) + *(*(*(A + Anext) + 1) + 0) * vi0) + *(*(*(A + Anext) + 1) + 1) * vi1) + *(*(*(A + Anext) + 1) + 2) * vi2;
    sum2 = ((*(*(w + i) + 2) + *(*(*(A + Anext) + 2) + 0) * vi0) + *(*(*(A + Anext) + 2) + 1) * vi1) + *(*(*(A + Anext) + 2) + 2) * vi2;
    Anext ++;
    while (Anext < Alast) {
      col = *(Acol + Anext);
      vcol0 = *(*(v + col) + 0);
      vcol1 = *(*(v + col) + 1);
      vcol2 = *(*(v + col) + 2);
      value = *(*(*(A + Anext) + 0) + 0);
      sum0 += value * vcol0;
      wcol0 = *(*(w + col) + 0) + value * vi0;
      value = *(*(*(A + Anext) + 0) + 1);
      sum0 += value * vcol1;
      wcol1 = *(*(w + col) + 1) + value * vi0;
      value = *(*(*(A + Anext) + 0) + 2);
      sum0 += value * vcol2;
      wcol2 = *(*(w + col) + 2) + value * vi0;
      value = *(*(*(A + Anext) + 1) + 0);
      sum1 += value * vcol0;
      wcol0 += value * vi1;
      value = *(*(*(A + Anext) + 1) + 1);
      sum1 += value * vcol1;
      wcol1 += value * vi1;
      value = *(*(*(A + Anext) + 1) + 2);
      sum1 += value * vcol2;
      wcol2 += value * vi1;
      value = *(*(*(A + Anext) + 2) + 0);
      sum2 += value * vcol0;
      *(*(w + col) + 0) = wcol0 + value * vi2;
      value = *(*(*(A + Anext) + 2) + 1);
      sum2 += value * vcol1;
      *(*(w + col) + 1) = wcol1 + value * vi2;
      value = *(*(*(A + Anext) + 2) + 2);
      sum2 += value * vcol2;
      *(*(w + col) + 2) = wcol2 + value * vi2;
      Anext ++;
    }
    *(*(w + i) + 0) = sum0;
    *(*(w + i) + 1) = sum1;
    *(*(w + i) + 2) = sum2;
    i ++;
  }
  return;
}
}
void mem_init(void) 
{ int i ;
  int j ;
  int k ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;

  {
  tmp = malloc((unsigned int )ARCHnodes * sizeof(double ));
  nodekindf = (double *)tmp;
  if ((unsigned int )nodekindf == (unsigned int )((double *)((void *)0))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for nodekindf\n");
    fflush(stderr);
    exit(0);
  }
  tmp___0 = malloc((unsigned int )ARCHnodes * sizeof(int ));
  nodekind = (int *)tmp___0;
  if ((unsigned int )nodekind == (unsigned int )((int *)((void *)0))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for nodekind\n");
    fflush(stderr);
    exit(0);
  }
  tmp___1 = malloc((unsigned int )ARCHelems * sizeof(int ));
  source_elms = (int *)tmp___1;
  if ((unsigned int )source_elms == (unsigned int )((int *)((void *)0))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for source_elms\n");
    fflush(stderr);
    exit(0);
  }
  tmp___2 = malloc((unsigned int )ARCHnodes * sizeof(double *));
  vel = (double **)tmp___2;
  if ((unsigned int )vel == (unsigned int )((double **)((void *)0))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for vel\n");
    fflush(stderr);
    exit(0);
  }
  i = 0;
  while (i < ARCHnodes) {
    tmp___3 = malloc(3U * sizeof(double ));
    *(vel + i) = (double *)tmp___3;
    if ((unsigned int )*(vel + i) == (unsigned int )((double *)((void *)0))) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for vel[%d]\n",
              i);
      fflush(stderr);
      exit(0);
    }
    i ++;
  }
  tmp___4 = malloc((unsigned int )ARCHnodes * sizeof(double *));
  M = (double **)tmp___4;
  if ((unsigned int )M == (unsigned int )((double **)((void *)0))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for M\n");
    fflush(stderr);
    exit(0);
  }
  i = 0;
  while (i < ARCHnodes) {
    tmp___5 = malloc(3U * sizeof(double ));
    *(M + i) = (double *)tmp___5;
    if ((unsigned int )*(M + i) == (unsigned int )((double *)((void *)0))) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for M[%d]\n",
              i);
      fflush(stderr);
      exit(0);
    }
    i ++;
  }
  tmp___6 = malloc((unsigned int )ARCHnodes * sizeof(double *));
  C = (double **)tmp___6;
  if ((unsigned int )C == (unsigned int )((double **)((void *)0))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for C\n");
    fflush(stderr);
    exit(0);
  }
  i = 0;
  while (i < ARCHnodes) {
    tmp___7 = malloc(3U * sizeof(double ));
    *(C + i) = (double *)tmp___7;
    if ((unsigned int )*(C + i) == (unsigned int )((double *)((void *)0))) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for C[%d]\n",
              i);
      fflush(stderr);
      exit(0);
    }
    i ++;
  }
  tmp___8 = malloc((unsigned int )ARCHnodes * sizeof(double *));
  M23 = (double **)tmp___8;
  if ((unsigned int )M23 == (unsigned int )((double **)((void *)0))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for M23\n");
    fflush(stderr);
    exit(0);
  }
  i = 0;
  while (i < ARCHnodes) {
    tmp___9 = malloc(3U * sizeof(double ));
    *(M23 + i) = (double *)tmp___9;
    if ((unsigned int )*(M23 + i) == (unsigned int )((double *)((void *)0))) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for M23[%d]\n",
              i);
      fflush(stderr);
      exit(0);
    }
    i ++;
  }
  tmp___10 = malloc((unsigned int )ARCHnodes * sizeof(double *));
  C23 = (double **)tmp___10;
  if ((unsigned int )C23 == (unsigned int )((double **)((void *)0))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for C23\n");
    fflush(stderr);
    exit(0);
  }
  i = 0;
  while (i < ARCHnodes) {
    tmp___11 = malloc(3U * sizeof(double ));
    *(C23 + i) = (double *)tmp___11;
    if ((unsigned int )*(C23 + i) == (unsigned int )((double *)((void *)0))) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for C23[%d]\n",
              i);
      fflush(stderr);
      exit(0);
    }
    i ++;
  }
  tmp___12 = malloc((unsigned int )ARCHnodes * sizeof(double *));
  V23 = (double **)tmp___12;
  if ((unsigned int )V23 == (unsigned int )((double **)((void *)0))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for V23\n");
    fflush(stderr);
    exit(0);
  }
  i = 0;
  while (i < ARCHnodes) {
    tmp___13 = malloc(3U * sizeof(double ));
    *(V23 + i) = (double *)tmp___13;
    if ((unsigned int )*(V23 + i) == (unsigned int )((double *)((void *)0))) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for V23[%d]\n",
              i);
      fflush(stderr);
      exit(0);
    }
    i ++;
  }
  tmp___14 = malloc(3U * sizeof(double **));
  disp = (double ***)tmp___14;
  if ((unsigned int )disp == (unsigned int )((double ***)((void *)0))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for disp\n");
    fflush(stderr);
    exit(0);
  }
  i = 0;
  while (i < 3) {
    tmp___15 = malloc((unsigned int )ARCHnodes * sizeof(double *));
    *(disp + i) = (double **)tmp___15;
    if ((unsigned int )*(disp + i) == (unsigned int )((double **)((void *)0))) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for disp[%d]\n",
              i);
      fflush(stderr);
      exit(0);
    }
    j = 0;
    while (j < ARCHnodes) {
      tmp___16 = malloc(3U * sizeof(double ));
      *(*(disp + i) + j) = (double *)tmp___16;
      if ((unsigned int )*(*(disp + i) + j) == (unsigned int )((double *)((void *)0))) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for disp[%d][%d]\n",
                i, j);
        fflush(stderr);
        exit(0);
      }
      j ++;
    }
    i ++;
  }
  tmp___17 = malloc((unsigned int )ARCHmatrixlen * sizeof(double **));
  K = (double ***)tmp___17;
  if ((unsigned int )K == (unsigned int )((double ***)((void *)0))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for K\n");
    fflush(stderr);
    exit(0);
  }
  i = 0;
  while (i < ARCHmatrixlen) {
    tmp___18 = malloc(3U * sizeof(double *));
    *(K + i) = (double **)tmp___18;
    if ((unsigned int )*(K + i) == (unsigned int )((double **)((void *)0))) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for K[%d]\n",
              i);
      fflush(stderr);
      exit(0);
    }
    j = 0;
    while (j < 3) {
      tmp___19 = malloc(3U * sizeof(double ));
      *(*(K + i) + j) = (double *)tmp___19;
      if ((unsigned int )*(*(K + i) + j) == (unsigned int )((double *)((void *)0))) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed for K[%d][%d]\n",
                i, j);
        fflush(stderr);
        exit(0);
      }
      j ++;
    }
    i ++;
  }
  i = 0;
  while (i < ARCHnodes) {
    *(nodekind + i) = 0;
    j = 0;
    while (j < 3) {
      *(*(M + i) + j) = 0.0;
      *(*(C + i) + j) = 0.0;
      *(*(M23 + i) + j) = 0.0;
      *(*(C23 + i) + j) = 0.0;
      *(*(V23 + i) + j) = 0.0;
      *(*(*(disp + 0) + i) + j) = 0.0;
      *(*(*(disp + 1) + i) + j) = 0.0;
      *(*(*(disp + 2) + i) + j) = 0.0;
      j ++;
    }
    i ++;
  }
  i = 0;
  while (i < ARCHelems) {
    *(source_elms + i) = 1;
    i ++;
  }
  i = 0;
  while (i < ARCHmatrixlen) {
    j = 0;
    while (j < 3) {
      k = 0;
      while (k < 3) {
        *(*(*(K + i) + j) + k) = 0.0;
        k ++;
      }
      j ++;
    }
    i ++;
  }
  return;
}
}
