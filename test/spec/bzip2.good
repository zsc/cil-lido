/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

typedef unsigned int size_t;
typedef long __off_t;
typedef long long __off64_t;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
struct _IO_FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15U * sizeof(int ) - 2U * sizeof(void *)] ;
};
struct __anonstruct_StackElem_46 {
   int ll ;
   int hh ;
   int dd ;
};
typedef struct __anonstruct_StackElem_46 StackElem;
extern struct _IO_FILE *stderr ;
extern int remove(char const   *__filename ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern void perror(char const   *__s ) ;
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern void free(void *__ptr ) ;
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
unsigned char uncompressStream(int zStream , int stream ) ;
void compressStream(int stream , int zStream ) ;
void allocateCompressStructures(void) ;
extern int spec_getc(int fd ) ;
extern int spec_ungetc(unsigned char ch , int fd ) ;
extern int spec_putc(unsigned char ch , int fd ) ;
unsigned int bytesIn  ;
unsigned int bytesOut  ;
int verbosity  ;
unsigned char keepInputFiles  ;
unsigned char smallMode  ;
unsigned char testFailsExist  ;
unsigned int globalCrc  ;
int numFileNames  =    0;
int numFilesProcessed  =    0;
int opMode  ;
int srcMode  ;
int longestFileName  ;
char inName[1024]  ;
char outName[1024]  ;
char *progName  ;
char progNameReally[1024]  ;
int outputHandleJustInCase  ;
void panic(char *s ) ;
void ioError(void) ;
void compressOutOfMemory(int draw , int blockSize ) ;
void uncompressOutOfMemory(int draw , int blockSize ) ;
void blockOverrun(void) ;
void badBlockHeader(void) ;
void badBGLengths(void) ;
void crcError(unsigned int crcStored , unsigned int crcComputed ) ;
void bitStreamEOF(void) ;
void cleanUpAndFail(int ec ) ;
void compressedStreamEOF(void) ;
unsigned char *block  ;
unsigned short *quadrant  ;
int *zptr  ;
unsigned short *szptr  ;
int *ftab  ;
unsigned short *ll16  ;
unsigned char *ll4  ;
int *tt  ;
unsigned char *ll8  ;
int unzftab[256]  ;
int last  ;
int origPtr  ;
int blockSize100k  ;
int workFactor  ;
int workDone  ;
int workLimit  ;
unsigned char blockRandomised  ;
unsigned char firstAttempt  ;
int nBlocksRandomised  ;
unsigned char inUse[256]  ;
int nInUse  ;
unsigned char seqToUnseq[256]  ;
unsigned char unseqToSeq[256]  ;
unsigned char selector[18002]  ;
unsigned char selectorMtf[18002]  ;
int nMTF  ;
int mtfFreq[258]  ;
unsigned char len[6][258]  ;
int limit[6][258]  ;
int base[6][258]  ;
int perm[6][258]  ;
int minLens[6]  ;
int code[6][258]  ;
int rfreq[6][258]  ;
unsigned int crc32Table[256]  = 
  {      0U,      79764919U,      159529838U,      222504665U, 
        319059676U,      398814059U,      445009330U,      507990021U, 
        638119352U,      583659535U,      797628118U,      726387553U, 
        890018660U,      835552979U,      1015980042U,      944750013U, 
        1276238704U,      1221641927U,      1167319070U,      1095957929U, 
        1595256236U,      1540665371U,      1452775106U,      1381403509U, 
        1780037320U,      1859660671U,      1671105958U,      1733955601U, 
        2031960084U,      2111593891U,      1889500026U,      1952343757U, 
        2552477408U,      2632100695U,      2443283854U,      2506133561U, 
        2334638140U,      2414271883U,      2191915858U,      2254759653U, 
        3190512472U,      3135915759U,      3081330742U,      3009969537U, 
        2905550212U,      2850959411U,      2762807018U,      2691435357U, 
        3560074640U,      3505614887U,      3719321342U,      3648080713U, 
        3342211916U,      3287746299U,      3467911202U,      3396681109U, 
        4063920168U,      4143685023U,      4223187782U,      4286162673U, 
        3779000052U,      3858754371U,      3904687514U,      3967668269U, 
        881225847U,      809987520U,      1023691545U,      969234094U, 
        662832811U,      591600412U,      771767749U,      717299826U, 
        311336399U,      374308984U,      453813921U,      533576470U, 
        25881363U,      88864420U,      134795389U,      214552010U, 
        2023205639U,      2086057648U,      1897238633U,      1976864222U, 
        1804852699U,      1867694188U,      1645340341U,      1724971778U, 
        1587496639U,      1516133128U,      1461550545U,      1406951526U, 
        1302016099U,      1230646740U,      1142491917U,      1087903418U, 
        2896545431U,      2825181984U,      2770861561U,      2716262478U, 
        3215044683U,      3143675388U,      3055782693U,      3001194130U, 
        2326604591U,      2389456536U,      2200899649U,      2280525302U, 
        2578013683U,      2640855108U,      2418763421U,      2498394922U, 
        3769900519U,      3832873040U,      3912640137U,      3992402750U, 
        4088425275U,      4151408268U,      4197601365U,      4277358050U, 
        3334271071U,      3263032808U,      3476998961U,      3422541446U, 
        3585640067U,      3514407732U,      3694837229U,      3640369242U, 
        1762451694U,      1842216281U,      1619975040U,      1682949687U, 
        2047383090U,      2127137669U,      1938468188U,      2001449195U, 
        1325665622U,      1271206113U,      1183200824U,      1111960463U, 
        1543535498U,      1489069629U,      1434599652U,      1363369299U, 
        622672798U,      568075817U,      748617968U,      677256519U, 
        907627842U,      853037301U,      1067152940U,      995781531U, 
        51762726U,      131386257U,      177728840U,      240578815U, 
        269590778U,      349224269U,      429104020U,      491947555U, 
        4046411278U,      4126034873U,      4172115296U,      4234965207U, 
        3794477266U,      3874110821U,      3953728444U,      4016571915U, 
        3609705398U,      3555108353U,      3735388376U,      3664026991U, 
        3290680682U,      3236090077U,      3449943556U,      3378572211U, 
        3174993278U,      3120533705U,      3032266256U,      2961025959U, 
        2923101090U,      2868635157U,      2813903052U,      2742672763U, 
        2604032198U,      2683796849U,      2461293480U,      2524268063U, 
        2284983834U,      2364738477U,      2175806836U,      2238787779U, 
        1569362073U,      1498123566U,      1409854455U,      1355396672U, 
        1317987909U,      1246755826U,      1192025387U,      1137557660U, 
        2072149281U,      2135122070U,      1912620623U,      1992383480U, 
        1753615357U,      1816598090U,      1627664531U,      1707420964U, 
        295390185U,      358241886U,      404320391U,      483945776U, 
        43990325U,      106832002U,      186451547U,      266083308U, 
        932423249U,      861060070U,      1041341759U,      986742920U, 
        613929101U,      542559546U,      756411363U,      701822548U, 
        3316196985U,      3244833742U,      3425377559U,      3370778784U, 
        3601682597U,      3530312978U,      3744426955U,      3689838204U, 
        3819031489U,      3881883254U,      3928223919U,      4007849240U, 
        4037393693U,      4100235434U,      4180117107U,      4259748804U, 
        2310601993U,      2373574846U,      2151335527U,      2231098320U, 
        2596047829U,      2659030626U,      2470359227U,      2550115596U, 
        2947551409U,      2876312838U,      2788305887U,      2733848168U, 
        3165939309U,      3094707162U,      3040238851U,      2985771188U};
void initialiseCRC(void) 
{ 

  {
  globalCrc = 4294967295U;
  return;
}
}
unsigned int getFinalCRC(void) 
{ 

  {
  return (~ globalCrc);
}
}
unsigned int getGlobalCRC(void) 
{ 

  {
  return (globalCrc);
}
}
void setGlobalCRC(unsigned int newCrc ) 
{ 

  {
  globalCrc = newCrc;
  return;
}
}
unsigned int bsBuff  ;
int bsLive  ;
int bsStream  ;
unsigned char bsWriting  ;
void bsSetStream(int f , unsigned char wr ) 
{ 

  {
  bsStream = f;
  bsLive = 0;
  bsBuff = 0U;
  bytesOut = 0U;
  bytesIn = 0U;
  bsWriting = wr;
  return;
}
}
void bsFinishedWithStream(void) 
{ 

  {
  if (bsWriting) {
    while (bsLive > 0) {
      spec_putc((unsigned char )(bsBuff >> 24), bsStream);
      bsBuff <<= 8;
      bsLive -= 8;
      bytesOut ++;
    }
  }
  bsStream = 0;
  return;
}
}
unsigned int bsR(int n ) 
{ unsigned int v ;
  int zzi ;
  int tmp ;

  {
  while (bsLive < n) {
    tmp = spec_getc(bsStream);
    zzi = tmp;
    if (zzi == -1) {
      compressedStreamEOF();
    }
    bsBuff = (unsigned int )((unsigned long )(bsBuff << 8) | (unsigned long )((long )zzi & 255L));
    bsLive += 8;
  }
  v = (bsBuff >> (bsLive - n)) & (unsigned int )((1 << n) - 1);
  bsLive -= n;
  return (v);
}
}
void bsW(int n , unsigned int v ) 
{ 

  {
  while (bsLive >= 8) {
    spec_putc((unsigned char )(bsBuff >> 24), bsStream);
    bsBuff <<= 8;
    bsLive -= 8;
    bytesOut ++;
  }
  bsBuff |= v << ((32 - bsLive) - n);
  bsLive += n;
  return;
}
}
unsigned char bsGetUChar(void) 
{ unsigned int tmp ;

  {
  tmp = bsR(8);
  return ((unsigned char )tmp);
}
}
void bsPutUChar(unsigned char c ) 
{ 

  {
  bsW(8, (unsigned int )c);
  return;
}
}
int bsGetUInt32(void) 
{ unsigned int u ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
  u = 0U;
  tmp = bsR(8);
  u = (u << 8) | tmp;
  tmp___0 = bsR(8);
  u = (u << 8) | tmp___0;
  tmp___1 = bsR(8);
  u = (u << 8) | tmp___1;
  tmp___2 = bsR(8);
  u = (u << 8) | tmp___2;
  return ((int )u);
}
}
unsigned int bsGetIntVS(unsigned int numBits ) 
{ unsigned int tmp ;

  {
  tmp = bsR((int )numBits);
  return (tmp);
}
}
unsigned int bsGetInt32(void) 
{ int tmp ;

  {
  tmp = bsGetUInt32();
  return ((unsigned int )tmp);
}
}
void bsPutUInt32(unsigned int u ) 
{ 

  {
  bsW(8, (unsigned int )((unsigned long )(u >> 24) & 255UL));
  bsW(8, (unsigned int )((unsigned long )(u >> 16) & 255UL));
  bsW(8, (unsigned int )((unsigned long )(u >> 8) & 255UL));
  bsW(8, (unsigned int )((unsigned long )u & 255UL));
  return;
}
}
void bsPutInt32(int c ) 
{ 

  {
  bsPutUInt32((unsigned int )c);
  return;
}
}
void bsPutIntVS(int numBits , unsigned int c ) 
{ 

  {
  bsW(numBits, c);
  return;
}
}
void hbMakeCodeLengths(unsigned char *len___0 , int *freq , int alphaSize , int maxLen ) 
{ int nNodes ;
  int nHeap ;
  int n1 ;
  int n2 ;
  int i ;
  int j ;
  int k ;
  unsigned char tooLong ;
  int heap[260] ;
  int weight[516] ;
  int parent[516] ;
  int tmp ;
  int zz ;
  int tmp___0 ;
  int zz___0 ;
  int yy ;
  int tmp___1 ;
  int zz___1 ;
  int yy___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int zz___2 ;
  int tmp___4 ;

  {
  i = 0;
  while (i < alphaSize) {
    if (*(freq + i) == 0) {
      tmp = 1;
    } else {
      tmp = *(freq + i);
    }
    weight[i + 1] = tmp << 8;
    i ++;
  }
  while (1) {
    nNodes = alphaSize;
    nHeap = 0;
    heap[0] = 0;
    weight[0] = 0;
    parent[0] = -2;
    i = 1;
    while (i <= alphaSize) {
      parent[i] = -1;
      nHeap ++;
      heap[nHeap] = i;
      zz = nHeap;
      tmp___0 = heap[zz];
      while (weight[tmp___0] < weight[heap[zz >> 1]]) {
        heap[zz] = heap[zz >> 1];
        zz >>= 1;
      }
      heap[zz] = tmp___0;
      i ++;
    }
    if (! (nHeap < 260)) {
      panic((char *)"hbMakeCodeLengths(1)");
    }
    while (nHeap > 1) {
      n1 = heap[1];
      heap[1] = heap[nHeap];
      nHeap --;
      zz___0 = 1;
      tmp___1 = heap[zz___0];
      while (1) {
        yy = zz___0 << 1;
        if (yy > nHeap) {
          break;
        }
        if (yy < nHeap) {
          if (weight[heap[yy + 1]] < weight[heap[yy]]) {
            yy ++;
          }
        }
        if (weight[tmp___1] < weight[heap[yy]]) {
          break;
        }
        heap[zz___0] = heap[yy];
        zz___0 = yy;
      }
      heap[zz___0] = tmp___1;
      n2 = heap[1];
      heap[1] = heap[nHeap];
      nHeap --;
      zz___1 = 1;
      tmp___2 = heap[zz___1];
      while (1) {
        yy___0 = zz___1 << 1;
        if (yy___0 > nHeap) {
          break;
        }
        if (yy___0 < nHeap) {
          if (weight[heap[yy___0 + 1]] < weight[heap[yy___0]]) {
            yy___0 ++;
          }
        }
        if (weight[tmp___2] < weight[heap[yy___0]]) {
          break;
        }
        heap[zz___1] = heap[yy___0];
        zz___1 = yy___0;
      }
      heap[zz___1] = tmp___2;
      nNodes ++;
      parent[n2] = nNodes;
      parent[n1] = parent[n2];
      if ((weight[n1] & 255) > (weight[n2] & 255)) {
        tmp___3 = weight[n1] & 255;
      } else {
        tmp___3 = weight[n2] & 255;
      }
      weight[nNodes] = (int )((((unsigned int )weight[n1] & 4294967040U) + ((unsigned int )weight[n2] & 4294967040U)) | (unsigned int )(1 + tmp___3));
      parent[nNodes] = -1;
      nHeap ++;
      heap[nHeap] = nNodes;
      zz___2 = nHeap;
      tmp___4 = heap[zz___2];
      while (weight[tmp___4] < weight[heap[zz___2 >> 1]]) {
        heap[zz___2] = heap[zz___2 >> 1];
        zz___2 >>= 1;
      }
      heap[zz___2] = tmp___4;
    }
    if (! (nNodes < 516)) {
      panic((char *)"hbMakeCodeLengths(2)");
    }
    tooLong = (unsigned char)0;
    i = 1;
    while (i <= alphaSize) {
      j = 0;
      k = i;
      while (parent[k] >= 0) {
        k = parent[k];
        j ++;
      }
      *(len___0 + (i - 1)) = (unsigned char )j;
      if (j > maxLen) {
        tooLong = (unsigned char)1;
      }
      i ++;
    }
    if (! tooLong) {
      break;
    }
    i = 1;
    while (i < alphaSize) {
      j = weight[i] >> 8;
      j = 1 + j / 2;
      weight[i] = j << 8;
      i ++;
    }
  }
  return;
}
}
void hbAssignCodes(int *code___0 , unsigned char *length , int minLen , int maxLen ,
                   int alphaSize ) 
{ int n ;
  int vec ;
  int i ;

  {
  vec = 0;
  n = minLen;
  while (n <= maxLen) {
    i = 0;
    while (i < alphaSize) {
      if ((int )*(length + i) == n) {
        *(code___0 + i) = vec;
        vec ++;
      }
      i ++;
    }
    vec <<= 1;
    n ++;
  }
  return;
}
}
void hbCreateDecodeTables(int *limit___0 , int *base___0 , int *perm___0 , unsigned char *length ,
                          int minLen , int maxLen , int alphaSize ) 
{ int pp ;
  int i ;
  int j ;
  int vec ;

  {
  pp = 0;
  i = minLen;
  while (i <= maxLen) {
    j = 0;
    while (j < alphaSize) {
      if ((int )*(length + j) == i) {
        *(perm___0 + pp) = j;
        pp ++;
      }
      j ++;
    }
    i ++;
  }
  i = 0;
  while (i < 23) {
    *(base___0 + i) = 0;
    i ++;
  }
  i = 0;
  while (i < alphaSize) {
    (*(base___0 + ((int )*(length + i) + 1))) ++;
    i ++;
  }
  i = 1;
  while (i < 23) {
    *(base___0 + i) += *(base___0 + (i - 1));
    i ++;
  }
  i = 0;
  while (i < 23) {
    *(limit___0 + i) = 0;
    i ++;
  }
  vec = 0;
  i = minLen;
  while (i <= maxLen) {
    vec += *(base___0 + (i + 1)) - *(base___0 + i);
    *(limit___0 + i) = vec - 1;
    vec <<= 1;
    i ++;
  }
  i = minLen + 1;
  while (i <= maxLen) {
    *(base___0 + i) = ((*(limit___0 + (i - 1)) + 1) << 1) - *(base___0 + i);
    i ++;
  }
  return;
}
}
void allocateCompressStructures(void) 
{ int n ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int totalDraw ;

  {
  n = 100000 * blockSize100k;
  tmp = malloc((unsigned int )((n + 1) + 20) * sizeof(unsigned char ));
  block = (unsigned char *)tmp;
  tmp___0 = malloc((unsigned int )(n + 20) * sizeof(short ));
  quadrant = (unsigned short *)tmp___0;
  tmp___1 = malloc((unsigned int )n * sizeof(int ));
  zptr = (int *)tmp___1;
  tmp___2 = malloc(65537U * sizeof(int ));
  ftab = (int *)tmp___2;
  if ((unsigned int )block == (unsigned int )((void *)0)) {
    totalDraw = (int )((((unsigned int )((n + 1) + 20) * sizeof(unsigned char ) + (unsigned int )(n + 20) * sizeof(short )) + (unsigned int )n * sizeof(int )) + 65537U * sizeof(int ));
    compressOutOfMemory(totalDraw, n);
  } else {
    if ((unsigned int )quadrant == (unsigned int )((void *)0)) {
      totalDraw = (int )((((unsigned int )((n + 1) + 20) * sizeof(unsigned char ) + (unsigned int )(n + 20) * sizeof(short )) + (unsigned int )n * sizeof(int )) + 65537U * sizeof(int ));
      compressOutOfMemory(totalDraw, n);
    } else {
      if ((unsigned int )zptr == (unsigned int )((void *)0)) {
        totalDraw = (int )((((unsigned int )((n + 1) + 20) * sizeof(unsigned char ) + (unsigned int )(n + 20) * sizeof(short )) + (unsigned int )n * sizeof(int )) + 65537U * sizeof(int ));
        compressOutOfMemory(totalDraw, n);
      } else {
        if ((unsigned int )ftab == (unsigned int )((void *)0)) {
          totalDraw = (int )((((unsigned int )((n + 1) + 20) * sizeof(unsigned char ) + (unsigned int )(n + 20) * sizeof(short )) + (unsigned int )n * sizeof(int )) + 65537U * sizeof(int ));
          compressOutOfMemory(totalDraw, n);
        }
      }
    }
  }
  block ++;
  szptr = (unsigned short *)zptr;
  return;
}
}
void setDecompressStructureSizes(int newSize100k ) 
{ int n ;
  void *tmp ;
  void *tmp___0 ;
  int totalDraw ;
  int n___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int totalDraw___0 ;

  {
  if (0 <= newSize100k) {
    if (newSize100k <= 9) {
      if (0 <= blockSize100k) {
        if (! (blockSize100k <= 9)) {
          panic((char *)"setDecompressStructureSizes");
        }
      } else {
        panic((char *)"setDecompressStructureSizes");
      }
    } else {
      panic((char *)"setDecompressStructureSizes");
    }
  } else {
    panic((char *)"setDecompressStructureSizes");
  }
  if (newSize100k == blockSize100k) {
    return;
  }
  blockSize100k = newSize100k;
  if ((unsigned int )ll16 != (unsigned int )((void *)0)) {
    free((void *)ll16);
  }
  if ((unsigned int )ll4 != (unsigned int )((void *)0)) {
    free((void *)ll4);
  }
  if ((unsigned int )ll8 != (unsigned int )((void *)0)) {
    free((void *)ll8);
  }
  if ((unsigned int )tt != (unsigned int )((void *)0)) {
    free((void *)tt);
  }
  if (newSize100k == 0) {
    return;
  }
  if (smallMode) {
    n = 100000 * newSize100k;
    tmp = malloc((unsigned int )n * sizeof(unsigned short ));
    ll16 = (unsigned short *)tmp;
    tmp___0 = malloc((unsigned int )((n + 1) >> 1) * sizeof(unsigned char ));
    ll4 = (unsigned char *)tmp___0;
    if ((unsigned int )ll4 == (unsigned int )((void *)0)) {
      totalDraw = (int )((unsigned int )n * sizeof(short ) + (unsigned int )((n + 1) >> 1) * sizeof(unsigned char ));
      uncompressOutOfMemory(totalDraw, n);
    } else {
      if ((unsigned int )ll16 == (unsigned int )((void *)0)) {
        totalDraw = (int )((unsigned int )n * sizeof(short ) + (unsigned int )((n + 1) >> 1) * sizeof(unsigned char ));
        uncompressOutOfMemory(totalDraw, n);
      }
    }
  } else {
    n___0 = 100000 * newSize100k;
    tmp___1 = malloc((unsigned int )n___0 * sizeof(unsigned char ));
    ll8 = (unsigned char *)tmp___1;
    tmp___2 = malloc((unsigned int )n___0 * sizeof(int ));
    tt = (int *)tmp___2;
    if ((unsigned int )ll8 == (unsigned int )((void *)0)) {
      totalDraw___0 = (int )((unsigned int )n___0 * sizeof(unsigned char ) + (unsigned int )n___0 * sizeof(unsigned int ));
      uncompressOutOfMemory(totalDraw___0, n___0);
    } else {
      if ((unsigned int )tt == (unsigned int )((void *)0)) {
        totalDraw___0 = (int )((unsigned int )n___0 * sizeof(unsigned char ) + (unsigned int )n___0 * sizeof(unsigned int ));
        uncompressOutOfMemory(totalDraw___0, n___0);
      }
    }
  }
  return;
}
}
void makeMaps(void) 
{ int i ;

  {
  nInUse = 0;
  i = 0;
  while (i < 256) {
    if (inUse[i]) {
      seqToUnseq[nInUse] = (unsigned char )i;
      unseqToSeq[i] = (unsigned char )nInUse;
      nInUse ++;
    }
    i ++;
  }
  return;
}
}
void generateMTFValues(void) 
{ unsigned char *yy ;
  int i ;
  int j ;
  unsigned char tmp ;
  unsigned char tmp2 ;
  int zPend ;
  int wr ;
  int EOB ;
  unsigned char ll_i ;
  unsigned long long __cil_tmp10[(256 * 1 + (8 - 1)) / 8] ;

  {
  yy = __cil_tmp10;
  makeMaps();
  EOB = nInUse + 1;
  i = 0;
  while (i <= EOB) {
    mtfFreq[i] = 0;
    i ++;
  }
  wr = 0;
  zPend = 0;
  i = 0;
  while (i < nInUse) {
    yy[i] = (unsigned char )i;
    i ++;
  }
  i = 0;
  while (i <= last) {
    ll_i = unseqToSeq[*(block + (*(zptr + i) - 1))];
    j = 0;
    j = rotr_till(yy, (int )ll_i);
    if (j == 0) {
      zPend ++;
    } else {
      if (zPend > 0) {
        zPend --;
        while (1) {
          switch (zPend % 2) {
          case 0: 
          *(szptr + wr) = (unsigned short)0;
          wr ++;
          (mtfFreq[0]) ++;
          break;
          case 1: 
          *(szptr + wr) = (unsigned short)1;
          wr ++;
          (mtfFreq[1]) ++;
          break;
          }
          if (zPend < 2) {
            break;
          }
          zPend = (zPend - 2) / 2;
        }
        zPend = 0;
      }
      *(szptr + wr) = (unsigned short )(j + 1);
      wr ++;
      (mtfFreq[j + 1]) ++;
    }
    i ++;
  }
  if (zPend > 0) {
    zPend --;
    while (1) {
      switch (zPend % 2) {
      case 0: 
      *(szptr + wr) = (unsigned short)0;
      wr ++;
      (mtfFreq[0]) ++;
      break;
      case 1: 
      *(szptr + wr) = (unsigned short)1;
      wr ++;
      (mtfFreq[1]) ++;
      break;
      }
      if (zPend < 2) {
        break;
      }
      zPend = (zPend - 2) / 2;
    }
  }
  *(szptr + wr) = (unsigned short )EOB;
  wr ++;
  (mtfFreq[EOB]) ++;
  nMTF = wr;
  return;
}
}
void sendMTFValues(void) 
{ int v ;
  int t ;
  int i ;
  int j ;
  int gs ;
  int ge ;
  int totc ;
  int bt ;
  int bc ;
  int iter ;
  int nSelectors ;
  int alphaSize ;
  int minLen ;
  int maxLen ;
  int selCtr ;
  int nGroups ;
  int nBytes ;
  unsigned short cost[6] ;
  int fave[6] ;
  int nPart ;
  int remF ;
  int tFreq ;
  int aFreq ;
  register unsigned short cost0 ;
  register unsigned short cost1 ;
  register unsigned short cost2 ;
  register unsigned short cost3 ;
  register unsigned short cost4 ;
  register unsigned short cost5 ;
  unsigned short icv ;
  unsigned short icv___0 ;
  unsigned char pos[6] ;
  unsigned char ll_i ;
  unsigned char tmp2 ;
  unsigned char tmp ;
  unsigned char inUse16[16] ;
  int curr ;

  {
  if (verbosity >= 3) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"      %d in block, %d after MTF & 1-2 coding, %d+2 syms in use\n",
            last + 1, nMTF, nInUse);
  }
  alphaSize = nInUse + 2;
  t = 0;
  while (t < 6) {
    v = 0;
    while (v < alphaSize) {
      len[t][v] = (unsigned char)15;
      v ++;
    }
    t ++;
  }
  if (nMTF <= 0) {
    panic((char *)"sendMTFValues(0)");
  }
  if (nMTF < 200) {
    nGroups = 2;
  } else {
    if (nMTF < 800) {
      nGroups = 4;
    } else {
      nGroups = 6;
    }
  }
  nPart = nGroups;
  remF = nMTF;
  gs = 0;
  while (nPart > 0) {
    tFreq = remF / nPart;
    ge = gs - 1;
    aFreq = 0;
    while (1) {
      if (aFreq < tFreq) {
        if (! (ge < alphaSize - 1)) {
          break;
        }
      } else {
        break;
      }
      ge ++;
      aFreq += mtfFreq[ge];
    }
    if (ge > gs) {
      if (nPart != nGroups) {
        if (nPart != 1) {
          if ((nGroups - nPart) % 2 == 1) {
            aFreq -= mtfFreq[ge];
            ge --;
          }
        }
      }
    }
    if (verbosity >= 3) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"      initial group %d, [%d .. %d], has %d syms (%4.1f%%)\n",
              nPart, gs, ge, aFreq, (100.0 * (double )((float )aFreq)) / (double )((float )nMTF));
    }
    v = 0;
    while (v < alphaSize) {
      if (v >= gs) {
        if (v <= ge) {
          len[nPart - 1][v] = (unsigned char)0;
        } else {
          len[nPart - 1][v] = (unsigned char)15;
        }
      } else {
        len[nPart - 1][v] = (unsigned char)15;
      }
      v ++;
    }
    nPart --;
    gs = ge + 1;
    remF -= aFreq;
  }
  iter = 0;
  while (iter < 4) {
    t = 0;
    while (t < nGroups) {
      fave[t] = 0;
      t ++;
    }
    t = 0;
    while (t < nGroups) {
      v = 0;
      while (v < alphaSize) {
        rfreq[t][v] = 0;
        v ++;
      }
      t ++;
    }
    nSelectors = 0;
    totc = 0;
    gs = 0;
    while (! (gs >= nMTF)) {
      ge = (gs + 50) - 1;
      if (ge >= nMTF) {
        ge = nMTF - 1;
      }
      t = 0;
      while (t < nGroups) {
        cost[t] = (unsigned short)0;
        t ++;
      }
      if (nGroups == 6) {
        cost5 = (unsigned short)0;
        cost4 = cost5;
        cost3 = cost4;
        cost2 = cost3;
        cost1 = cost2;
        cost0 = cost1;
        i = gs;
        while (i <= ge) {
          icv = *(szptr + i);
          cost0 = (unsigned short )((int )cost0 + (int )len[0][icv]);
          cost1 = (unsigned short )((int )cost1 + (int )len[1][icv]);
          cost2 = (unsigned short )((int )cost2 + (int )len[2][icv]);
          cost3 = (unsigned short )((int )cost3 + (int )len[3][icv]);
          cost4 = (unsigned short )((int )cost4 + (int )len[4][icv]);
          cost5 = (unsigned short )((int )cost5 + (int )len[5][icv]);
          i ++;
        }
        cost[0] = cost0;
        cost[1] = cost1;
        cost[2] = cost2;
        cost[3] = cost3;
        cost[4] = cost4;
        cost[5] = cost5;
      } else {
        i = gs;
        while (i <= ge) {
          icv___0 = *(szptr + i);
          t = 0;
          while (t < nGroups) {
            cost[t] = (unsigned short )((int )cost[t] + (int )len[t][icv___0]);
            t ++;
          }
          i ++;
        }
      }
      bc = 999999999;
      bt = -1;
      t = 0;
      while (t < nGroups) {
        if ((int )cost[t] < bc) {
          bc = (int )cost[t];
          bt = t;
        }
        t ++;
      }
      totc += bc;
      (fave[bt]) ++;
      selector[nSelectors] = (unsigned char )bt;
      nSelectors ++;
      i = gs;
      while (i <= ge) {
        (rfreq[bt][*(szptr + i)]) ++;
        i ++;
      }
      gs = ge + 1;
    }
    if (verbosity >= 3) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"      pass %d: size is %d, grp uses are ",
              iter + 1, totc / 8);
      t = 0;
      while (t < nGroups) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%d ", fave[t]);
        t ++;
      }
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    }
    t = 0;
    while (t < nGroups) {
      hbMakeCodeLengths(& len[t][0], & rfreq[t][0], alphaSize, 20);
      t ++;
    }
    iter ++;
  }
  if (! (nGroups < 8)) {
    panic((char *)"sendMTFValues(1)");
  }
  if (nSelectors < 32768) {
    if (! (nSelectors <= 18002)) {
      panic((char *)"sendMTFValues(2)");
    }
  } else {
    panic((char *)"sendMTFValues(2)");
  }
  i = 0;
  while (i < nGroups) {
    pos[i] = (unsigned char )i;
    i ++;
  }
  i = 0;
  while (i < nSelectors) {
    ll_i = selector[i];
    j = 0;
    j = rotr_till(pos, (int )ll_i);
    selectorMtf[i] = (unsigned char )j;
    i ++;
  }
  t = 0;
  while (t < nGroups) {
    minLen = 32;
    maxLen = 0;
    i = 0;
    while (i < alphaSize) {
      if ((int )len[t][i] > maxLen) {
        maxLen = (int )len[t][i];
      }
      if ((int )len[t][i] < minLen) {
        minLen = (int )len[t][i];
      }
      i ++;
    }
    if (maxLen > 20) {
      panic((char *)"sendMTFValues(3)");
    }
    if (minLen < 1) {
      panic((char *)"sendMTFValues(4)");
    }
    hbAssignCodes(& code[t][0], & len[t][0], minLen, maxLen, alphaSize);
    t ++;
  }
  i = 0;
  while (i < 16) {
    inUse16[i] = (unsigned char)0;
    j = 0;
    while (j < 16) {
      if (inUse[i * 16 + j]) {
        inUse16[i] = (unsigned char)1;
      }
      j ++;
    }
    i ++;
  }
  nBytes = (int )bytesOut;
  i = 0;
  while (i < 16) {
    if (inUse16[i]) {
      bsW(1, 1U);
    } else {
      bsW(1, 0U);
    }
    i ++;
  }
  i = 0;
  while (i < 16) {
    if (inUse16[i]) {
      j = 0;
      while (j < 16) {
        if (inUse[i * 16 + j]) {
          bsW(1, 1U);
        } else {
          bsW(1, 0U);
        }
        j ++;
      }
    }
    i ++;
  }
  if (verbosity >= 3) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"      bytes: mapping %d, ",
            bytesOut - (unsigned int )nBytes);
  }
  nBytes = (int )bytesOut;
  bsW(3, (unsigned int )nGroups);
  bsW(15, (unsigned int )nSelectors);
  i = 0;
  while (i < nSelectors) {
    j = 0;
    while (j < (int )selectorMtf[i]) {
      bsW(1, 1U);
      j ++;
    }
    bsW(1, 0U);
    i ++;
  }
  if (verbosity >= 3) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"selectors %d, ",
            bytesOut - (unsigned int )nBytes);
  }
  nBytes = (int )bytesOut;
  t = 0;
  while (t < nGroups) {
    curr = (int )len[t][0];
    bsW(5, (unsigned int )curr);
    i = 0;
    while (i < alphaSize) {
      while (curr < (int )len[t][i]) {
        bsW(2, 2U);
        curr ++;
      }
      while (curr > (int )len[t][i]) {
        bsW(2, 3U);
        curr --;
      }
      bsW(1, 0U);
      i ++;
    }
    t ++;
  }
  if (verbosity >= 3) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"code lengths %d, ",
            bytesOut - (unsigned int )nBytes);
  }
  nBytes = (int )bytesOut;
  selCtr = 0;
  gs = 0;
  while (! (gs >= nMTF)) {
    ge = (gs + 50) - 1;
    if (ge >= nMTF) {
      ge = nMTF - 1;
    }
    i = gs;
    while (i <= ge) {
      bsW((int )len[selector[selCtr]][*(szptr + i)], (unsigned int )code[selector[selCtr]][*(szptr + i)]);
      i ++;
    }
    gs = ge + 1;
    selCtr ++;
  }
  if (! (selCtr == nSelectors)) {
    panic((char *)"sendMTFValues(5)");
  }
  if (verbosity >= 3) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"codes %d\n",
            bytesOut - (unsigned int )nBytes);
  }
  return;
}
}
void moveToFrontCodeAndSend(void) 
{ 

  {
  bsPutIntVS(24, (unsigned int )origPtr);
  generateMTFValues();
  sendMTFValues();
  return;
}
}
void recvDecodingTables(void) 
{ int i ;
  int j ;
  int t ;
  int nGroups ;
  int nSelectors ;
  int alphaSize ;
  int minLen ;
  int maxLen ;
  unsigned char inUse16[16] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned char pos[6] ;
  unsigned char tmp___4 ;
  unsigned char v ;
  int curr ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;

  {
  i = 0;
  while (i < 16) {
    tmp = bsR(1);
    if (tmp == 1U) {
      inUse16[i] = (unsigned char)1;
    } else {
      inUse16[i] = (unsigned char)0;
    }
    i ++;
  }
  i = 0;
  while (i < 256) {
    inUse[i] = (unsigned char)0;
    i ++;
  }
  i = 0;
  while (i < 16) {
    if (inUse16[i]) {
      j = 0;
      while (j < 16) {
        tmp___0 = bsR(1);
        if (tmp___0 == 1U) {
          inUse[i * 16 + j] = (unsigned char)1;
        }
        j ++;
      }
    }
    i ++;
  }
  makeMaps();
  alphaSize = nInUse + 2;
  tmp___1 = bsR(3);
  nGroups = (int )tmp___1;
  tmp___2 = bsR(15);
  nSelectors = (int )tmp___2;
  i = 0;
  while (i < nSelectors) {
    j = 0;
    while (1) {
      tmp___3 = bsR(1);
      if (! (tmp___3 == 1U)) {
        break;
      }
      j ++;
    }
    selectorMtf[i] = (unsigned char )j;
    i ++;
  }
  v = (unsigned char)0;
  while ((int )v < nGroups) {
    pos[v] = v;
    v = (unsigned char )((int )v + 1);
  }
  i = 0;
  while (i < nSelectors) {
    v = selectorMtf[i];
    tmp___4 = pos[v];
    while ((int )v > 0) {
      pos[v] = pos[(int )v - 1];
      v = (unsigned char )((int )v - 1);
    }
    pos[0] = tmp___4;
    selector[i] = tmp___4;
    i ++;
  }
  t = 0;
  while (t < nGroups) {
    tmp___5 = bsR(5);
    curr = (int )tmp___5;
    i = 0;
    while (i < alphaSize) {
      while (1) {
        tmp___7 = bsR(1);
        if (! (tmp___7 == 1U)) {
          break;
        }
        tmp___6 = bsR(1);
        if (tmp___6 == 0U) {
          curr ++;
        } else {
          curr --;
        }
      }
      len[t][i] = (unsigned char )curr;
      i ++;
    }
    t ++;
  }
  t = 0;
  while (t < nGroups) {
    minLen = 32;
    maxLen = 0;
    i = 0;
    while (i < alphaSize) {
      if ((int )len[t][i] > maxLen) {
        maxLen = (int )len[t][i];
      }
      if ((int )len[t][i] < minLen) {
        minLen = (int )len[t][i];
      }
      i ++;
    }
    hbCreateDecodeTables(& limit[t][0], & base[t][0], & perm[t][0], & len[t][0], minLen,
                         maxLen, alphaSize);
    minLens[t] = minLen;
    t ++;
  }
  return;
}
}
void getAndMoveToFrontDecode(void) 
{ unsigned char *yy ;
  int i ;
  int j ;
  int nextSym ;
  int limitLast ;
  int EOB ;
  int groupNo ;
  int groupPos ;
  unsigned int tmp ;
  int zt ;
  int zn ;
  int zvec ;
  int zj ;
  unsigned int tmp___0 ;
  int zzi ;
  int tmp___1 ;
  unsigned char ch ;
  int s ;
  int N ;
  int zt___0 ;
  int zn___0 ;
  int zvec___0 ;
  int zj___0 ;
  unsigned int tmp___2 ;
  int zzi___0 ;
  int tmp___3 ;
  unsigned char tmp___4 ;
  int zt___1 ;
  int zn___1 ;
  int zvec___1 ;
  int zj___1 ;
  unsigned int tmp___5 ;
  int zzi___1 ;
  int tmp___6 ;
  unsigned long long __cil_tmp35[(256 * 1 + (8 - 1)) / 8] ;

  {
  yy = __cil_tmp35;
  limitLast = 100000 * blockSize100k;
  tmp = bsGetIntVS(24U);
  origPtr = (int )tmp;
  recvDecodingTables();
  EOB = nInUse + 1;
  groupNo = -1;
  groupPos = 0;
  i = 0;
  while (i <= 255) {
    unzftab[i] = 0;
    i ++;
  }
  i = 0;
  while (i <= 255) {
    yy[i] = (unsigned char )i;
    i ++;
  }
  last = -1;
  if (groupPos == 0) {
    groupNo ++;
    groupPos = 50;
  }
  groupPos --;
  zt = (int )selector[groupNo];
  zn = minLens[zt];
  tmp___0 = bsR(zn);
  zvec = (int )tmp___0;
  while (zvec > limit[zt][zn]) {
    zn ++;
    while (bsLive < 1) {
      tmp___1 = spec_getc(bsStream);
      zzi = tmp___1;
      if (zzi == -1) {
        compressedStreamEOF();
      }
      bsBuff = (unsigned int )((unsigned long )(bsBuff << 8) | (unsigned long )((long )zzi & 255L));
      bsLive += 8;
    }
    zj = (int )((bsBuff >> (bsLive - 1)) & 1U);
    bsLive --;
    zvec = (zvec << 1) | zj;
  }
  nextSym = perm[zt][zvec - base[zt][zn]];
  while (! (nextSym == EOB)) {
    if (nextSym == 0) {
      goto _L;
    } else {
      if (nextSym == 1) {
        _L: /* CIL Label */ 
        s = -1;
        N = 1;
        while (1) {
          if (nextSym == 0) {
            s += N;
          } else {
            if (nextSym == 1) {
              s += 2 * N;
            }
          }
          N *= 2;
          if (groupPos == 0) {
            groupNo ++;
            groupPos = 50;
          }
          groupPos --;
          zt___0 = (int )selector[groupNo];
          zn___0 = minLens[zt___0];
          tmp___2 = bsR(zn___0);
          zvec___0 = (int )tmp___2;
          while (zvec___0 > limit[zt___0][zn___0]) {
            zn___0 ++;
            while (bsLive < 1) {
              tmp___3 = spec_getc(bsStream);
              zzi___0 = tmp___3;
              if (zzi___0 == -1) {
                compressedStreamEOF();
              }
              bsBuff = (unsigned int )((unsigned long )(bsBuff << 8) | (unsigned long )((long )zzi___0 & 255L));
              bsLive += 8;
            }
            zj___0 = (int )((bsBuff >> (bsLive - 1)) & 1U);
            bsLive --;
            zvec___0 = (zvec___0 << 1) | zj___0;
          }
          nextSym = perm[zt___0][zvec___0 - base[zt___0][zn___0]];
          if (! (nextSym == 0)) {
            if (! (nextSym == 1)) {
              break;
            }
          }
        }
        s ++;
        ch = seqToUnseq[yy[0]];
        unzftab[ch] += s;
        if (smallMode) {
          while (s > 0) {
            last ++;
            *(ll16 + last) = (unsigned short )ch;
            s --;
          }
        } else {
          while (s > 0) {
            last ++;
            *(ll8 + last) = ch;
            s --;
          }
        }
        if (last >= limitLast) {
          blockOverrun();
        }
        continue;
      } else {
        last ++;
        if (last >= limitLast) {
          blockOverrun();
        }
        tmp___4 = yy[nextSym - 1];
        (unzftab[seqToUnseq[tmp___4]]) ++;
        if (smallMode) {
          *(ll16 + last) = (unsigned short )seqToUnseq[tmp___4];
        } else {
          *(ll8 + last) = seqToUnseq[tmp___4];
        }
        j = nextSym - 1;
        shiftr(yy, j, tmp___4);
        if (groupPos == 0) {
          groupNo ++;
          groupPos = 50;
        }
        groupPos --;
        zt___1 = (int )selector[groupNo];
        zn___1 = minLens[zt___1];
        tmp___5 = bsR(zn___1);
        zvec___1 = (int )tmp___5;
        while (zvec___1 > limit[zt___1][zn___1]) {
          zn___1 ++;
          while (bsLive < 1) {
            tmp___6 = spec_getc(bsStream);
            zzi___1 = tmp___6;
            if (zzi___1 == -1) {
              compressedStreamEOF();
            }
            bsBuff = (unsigned int )((unsigned long )(bsBuff << 8) | (unsigned long )((long )zzi___1 & 255L));
            bsLive += 8;
          }
          zj___1 = (int )((bsBuff >> (bsLive - 1)) & 1U);
          bsLive --;
          zvec___1 = (zvec___1 << 1) | zj___1;
        }
        nextSym = perm[zt___1][zvec___1 - base[zt___1][zn___1]];
        continue;
      }
    }
  }
  return;
}
}
unsigned char fullGtU(int i1 , int i2 ) 
{ int k ;
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned short s1 ;
  unsigned short s2 ;

  {
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((unsigned char )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((unsigned char )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((unsigned char )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((unsigned char )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((unsigned char )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  c1 = *(block + i1);
  c2 = *(block + i2);
  if ((int )c1 != (int )c2) {
    return ((unsigned char )((int )c1 > (int )c2));
  }
  i1 ++;
  i2 ++;
  k = last + 1;
  while (1) {
    c1 = *(block + i1);
    c2 = *(block + i2);
    if ((int )c1 != (int )c2) {
      return ((unsigned char )((int )c1 > (int )c2));
    }
    s1 = *(quadrant + i1);
    s2 = *(quadrant + i2);
    if ((int )s1 != (int )s2) {
      return ((unsigned char )((int )s1 > (int )s2));
    }
    i1 ++;
    i2 ++;
    c1 = *(block + i1);
    c2 = *(block + i2);
    if ((int )c1 != (int )c2) {
      return ((unsigned char )((int )c1 > (int )c2));
    }
    s1 = *(quadrant + i1);
    s2 = *(quadrant + i2);
    if ((int )s1 != (int )s2) {
      return ((unsigned char )((int )s1 > (int )s2));
    }
    i1 ++;
    i2 ++;
    c1 = *(block + i1);
    c2 = *(block + i2);
    if ((int )c1 != (int )c2) {
      return ((unsigned char )((int )c1 > (int )c2));
    }
    s1 = *(quadrant + i1);
    s2 = *(quadrant + i2);
    if ((int )s1 != (int )s2) {
      return ((unsigned char )((int )s1 > (int )s2));
    }
    i1 ++;
    i2 ++;
    c1 = *(block + i1);
    c2 = *(block + i2);
    if ((int )c1 != (int )c2) {
      return ((unsigned char )((int )c1 > (int )c2));
    }
    s1 = *(quadrant + i1);
    s2 = *(quadrant + i2);
    if ((int )s1 != (int )s2) {
      return ((unsigned char )((int )s1 > (int )s2));
    }
    i1 ++;
    i2 ++;
    if (i1 > last) {
      i1 -= last;
      i1 --;
    }
    if (i2 > last) {
      i2 -= last;
      i2 --;
    }
    k -= 4;
    workDone ++;
    if (! (k >= 0)) {
      break;
    }
  }
  return ((unsigned char)0);
}
}
int incs[14]  = 
  {      1,      4,      13,      40, 
        121,      364,      1093,      3280, 
        9841,      29524,      88573,      265720, 
        797161,      2391484};
void simpleSort(int lo , int hi , int d ) 
{ int i ;
  int j ;
  int h ;
  int bigN ;
  int hp ;
  int v ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;

  {
  bigN = (hi - lo) + 1;
  if (bigN < 2) {
    return;
  }
  hp = 0;
  while (incs[hp] < bigN) {
    hp ++;
  }
  hp --;
  while (hp >= 0) {
    h = incs[hp];
    if (verbosity >= 5) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"          shell increment %d\n",
              h);
    }
    i = lo + h;
    while (! (i > hi)) {
      v = *(zptr + i);
      j = i;
      while (1) {
        tmp = fullGtU(*(zptr + (j - h)) + d, v + d);
        if (! tmp) {
          break;
        }
        *(zptr + j) = *(zptr + (j - h));
        j -= h;
        if (j <= (lo + h) - 1) {
          break;
        }
      }
      *(zptr + j) = v;
      i ++;
      if (i > hi) {
        break;
      }
      v = *(zptr + i);
      j = i;
      while (1) {
        tmp___0 = fullGtU(*(zptr + (j - h)) + d, v + d);
        if (! tmp___0) {
          break;
        }
        *(zptr + j) = *(zptr + (j - h));
        j -= h;
        if (j <= (lo + h) - 1) {
          break;
        }
      }
      *(zptr + j) = v;
      i ++;
      if (i > hi) {
        break;
      }
      v = *(zptr + i);
      j = i;
      while (1) {
        tmp___1 = fullGtU(*(zptr + (j - h)) + d, v + d);
        if (! tmp___1) {
          break;
        }
        *(zptr + j) = *(zptr + (j - h));
        j -= h;
        if (j <= (lo + h) - 1) {
          break;
        }
      }
      *(zptr + j) = v;
      i ++;
      if (workDone > workLimit) {
        if (firstAttempt) {
          return;
        }
      }
    }
    hp --;
  }
  return;
}
}
void vswap(int p1 , int p2 , int n ) 
{ int tmp ;

  {
  while (n > 0) {
    tmp = *(zptr + p1);
    *(zptr + p1) = *(zptr + p2);
    *(zptr + p2) = tmp;
    p1 ++;
    p2 ++;
    n --;
  }
  return;
}
}
unsigned char med3(unsigned char a , unsigned char b , unsigned char c ) 
{ unsigned char t ;

  {
  if ((int )a > (int )b) {
    t = a;
    a = b;
    b = t;
  }
  if ((int )b > (int )c) {
    t = b;
    b = c;
    c = t;
  }
  if ((int )a > (int )b) {
    b = a;
  }
  return (b);
}
}
void qSort3(int loSt , int hiSt , int dSt ) 
{ int unLo ;
  int unHi ;
  int ltLo ;
  int gtHi ;
  int med ;
  int n ;
  int m ;
  int sp ;
  int lo ;
  int hi ;
  int d ;
  StackElem stack[1000] ;
  unsigned char tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  sp = 0;
  stack[sp].ll = loSt;
  stack[sp].hh = hiSt;
  stack[sp].dd = dSt;
  sp ++;
  while (sp > 0) {
    if (sp >= 1000) {
      panic((char *)"stack overflow in qSort3");
    }
    sp --;
    lo = stack[sp].ll;
    hi = stack[sp].hh;
    d = stack[sp].dd;
    if (hi - lo < 20) {
      goto _L;
    } else {
      if (d > 10) {
        _L: /* CIL Label */ 
        simpleSort(lo, hi, d);
        if (workDone > workLimit) {
          if (firstAttempt) {
            return;
          }
        }
        continue;
      }
    }
    tmp = med3(*(block + (*(zptr + lo) + d)), *(block + (*(zptr + hi) + d)), *(block + (*(zptr + ((lo + hi) >> 1)) + d)));
    med = (int )tmp;
    ltLo = lo;
    unLo = ltLo;
    gtHi = hi;
    unHi = gtHi;
    while (1) {
      while (! (unLo > unHi)) {
        n = (int )*(block + (*(zptr + unLo) + d)) - med;
        if (n == 0) {
          tmp___0 = *(zptr + unLo);
          *(zptr + unLo) = *(zptr + ltLo);
          *(zptr + ltLo) = tmp___0;
          ltLo ++;
          unLo ++;
          continue;
        }
        if (n > 0) {
          break;
        }
        unLo ++;
      }
      while (! (unLo > unHi)) {
        n = (int )*(block + (*(zptr + unHi) + d)) - med;
        if (n == 0) {
          tmp___1 = *(zptr + unHi);
          *(zptr + unHi) = *(zptr + gtHi);
          *(zptr + gtHi) = tmp___1;
          gtHi --;
          unHi --;
          continue;
        }
        if (n < 0) {
          break;
        }
        unHi --;
      }
      if (unLo > unHi) {
        break;
      }
      tmp___2 = *(zptr + unLo);
      *(zptr + unLo) = *(zptr + unHi);
      *(zptr + unHi) = tmp___2;
      unLo ++;
      unHi --;
    }
    if (gtHi < ltLo) {
      stack[sp].ll = lo;
      stack[sp].hh = hi;
      stack[sp].dd = d + 1;
      sp ++;
      continue;
    }
    if (ltLo - lo < unLo - ltLo) {
      n = ltLo - lo;
    } else {
      n = unLo - ltLo;
    }
    vswap(lo, unLo - n, n);
    if (hi - gtHi < gtHi - unHi) {
      m = hi - gtHi;
    } else {
      m = gtHi - unHi;
    }
    vswap(unLo, (hi - m) + 1, m);
    n = ((lo + unLo) - ltLo) - 1;
    m = (hi - (gtHi - unHi)) + 1;
    stack[sp].ll = lo;
    stack[sp].hh = n;
    stack[sp].dd = d;
    sp ++;
    stack[sp].ll = n + 1;
    stack[sp].hh = m - 1;
    stack[sp].dd = d + 1;
    sp ++;
    stack[sp].ll = m;
    stack[sp].hh = hi;
    stack[sp].dd = d;
    sp ++;
  }
  return;
}
}
void sortIt(void) 
{ int i ;
  int j ;
  int ss ;
  int sb ;
  int runningOrder[256] ;
  int copy[256] ;
  unsigned char bigDone[256] ;
  unsigned char c1 ;
  unsigned char c2 ;
  int numQSorted ;
  int vv ;
  int h ;
  int lo ;
  int hi ;
  int bbStart ;
  int bbSize ;
  int shifts ;
  int a2update ;
  unsigned short qVal ;

  {
  if (verbosity >= 4) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"        sort initialise ...\n");
  }
  i = 0;
  while (i < 20) {
    *(block + ((last + i) + 1)) = *(block + i % (last + 1));
    i ++;
  }
  i = 0;
  while (i <= last + 20) {
    *(quadrant + i) = (unsigned short)0;
    i ++;
  }
  *(block + -1) = *(block + last);
  if (last < 4000) {
    if (verbosity >= 4) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"        simpleSort ...\n");
    }
    i = 0;
    while (i <= last) {
      *(zptr + i) = i;
      i ++;
    }
    firstAttempt = (unsigned char)0;
    workLimit = 0;
    workDone = workLimit;
    simpleSort(0, last, 0);
    if (verbosity >= 4) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"        simpleSort done.\n");
    }
  } else {
    numQSorted = 0;
    i = 0;
    while (i <= 255) {
      bigDone[i] = (unsigned char)0;
      i ++;
    }
    if (verbosity >= 4) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"        bucket sorting ...\n");
    }
    i = 0;
    while (i <= 65536) {
      *(ftab + i) = 0;
      i ++;
    }
    c1 = *(block + -1);
    i = 0;
    while (i <= last) {
      c2 = *(block + i);
      (*(ftab + (((int )c1 << 8) + (int )c2))) ++;
      c1 = c2;
      i ++;
    }
    i = 1;
    while (i <= 65536) {
      *(ftab + i) += *(ftab + (i - 1));
      i ++;
    }
    c1 = *(block + 0);
    i = 0;
    while (i < last) {
      c2 = *(block + (i + 1));
      j = ((int )c1 << 8) + (int )c2;
      c1 = c2;
      (*(ftab + j)) --;
      *(zptr + *(ftab + j)) = i;
      i ++;
    }
    j = ((int )*(block + last) << 8) + (int )*(block + 0);
    (*(ftab + j)) --;
    *(zptr + *(ftab + j)) = last;
    i = 0;
    while (i <= 255) {
      runningOrder[i] = i;
      i ++;
    }
    h = 1;
    while (1) {
      h = 3 * h + 1;
      if (! (h <= 256)) {
        break;
      }
    }
    while (1) {
      h /= 3;
      i = h;
      while (i <= 255) {
        vv = runningOrder[i];
        j = i;
        while (*(ftab + ((runningOrder[j - h] + 1) << 8)) - *(ftab + (runningOrder[j - h] << 8)) > *(ftab + ((vv + 1) << 8)) - *(ftab + (vv << 8))) {
          runningOrder[j] = runningOrder[j - h];
          j -= h;
          if (j <= h - 1) {
            goto zero;
          }
        }
        zero: 
        runningOrder[j] = vv;
        i ++;
      }
      if (! (h != 1)) {
        break;
      }
    }
    i = 0;
    while (i <= 255) {
      ss = runningOrder[i];
      j = 0;
      while (j <= 255) {
        sb = (ss << 8) + j;
        if (! (*(ftab + sb) & (1 << 21))) {
          lo = *(ftab + sb) & ~ (1 << 21);
          hi = (*(ftab + (sb + 1)) & ~ (1 << 21)) - 1;
          if (hi > lo) {
            if (verbosity >= 4) {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"        qsort [0x%x, 0x%x]   done %d   this %d\n",
                      ss, j, numQSorted, (hi - lo) + 1);
            }
            qSort3(lo, hi, 2);
            numQSorted += (hi - lo) + 1;
            if (workDone > workLimit) {
              if (firstAttempt) {
                return;
              }
            }
          }
          *(ftab + sb) |= 1 << 21;
        }
        j ++;
      }
      bigDone[ss] = (unsigned char)1;
      if (i < 255) {
        bbStart = *(ftab + (ss << 8)) & ~ (1 << 21);
        bbSize = (*(ftab + ((ss + 1) << 8)) & ~ (1 << 21)) - bbStart;
        shifts = 0;
        while (bbSize >> shifts > 65534) {
          shifts ++;
        }
        j = 0;
        while (j < bbSize) {
          a2update = *(zptr + (bbStart + j));
          qVal = (unsigned short )(j >> shifts);
          *(quadrant + a2update) = qVal;
          if (a2update < 20) {
            *(quadrant + ((a2update + last) + 1)) = qVal;
          }
          j ++;
        }
        if (! ((bbSize - 1) >> shifts <= 65535)) {
          panic((char *)"sortIt");
        }
      }
      j = 0;
      while (j <= 255) {
        copy[j] = *(ftab + ((j << 8) + ss)) & ~ (1 << 21);
        j ++;
      }
      j = *(ftab + (ss << 8)) & ~ (1 << 21);
      while (j < (*(ftab + ((ss + 1) << 8)) & ~ (1 << 21))) {
        c1 = *(block + (*(zptr + j) - 1));
        if (! bigDone[c1]) {
          if (*(zptr + j) == 0) {
            *(zptr + copy[c1]) = last;
          } else {
            *(zptr + copy[c1]) = *(zptr + j) - 1;
          }
          (copy[c1]) ++;
        }
        j ++;
      }
      j = 0;
      while (j <= 255) {
        *(ftab + ((j << 8) + ss)) |= 1 << 21;
        j ++;
      }
      i ++;
    }
    if (verbosity >= 4) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"        %d pointers, %d sorted, %d scanned\n",
              last + 1, numQSorted, (last + 1) - numQSorted);
    }
  }
  return;
}
}
int rNums[512]  = 
  {      619,      720,      127,      481, 
        931,      816,      813,      233, 
        566,      247,      985,      724, 
        205,      454,      863,      491, 
        741,      242,      949,      214, 
        733,      859,      335,      708, 
        621,      574,      73,      654, 
        730,      472,      419,      436, 
        278,      496,      867,      210, 
        399,      680,      480,      51, 
        878,      465,      811,      169, 
        869,      675,      611,      697, 
        867,      561,      862,      687, 
        507,      283,      482,      129, 
        807,      591,      733,      623, 
        150,      238,      59,      379, 
        684,      877,      625,      169, 
        643,      105,      170,      607, 
        520,      932,      727,      476, 
        693,      425,      174,      647, 
        73,      122,      335,      530, 
        442,      853,      695,      249, 
        445,      515,      909,      545, 
        703,      919,      874,      474, 
        882,      500,      594,      612, 
        641,      801,      220,      162, 
        819,      984,      589,      513, 
        495,      799,      161,      604, 
        958,      533,      221,      400, 
        386,      867,      600,      782, 
        382,      596,      414,      171, 
        516,      375,      682,      485, 
        911,      276,      98,      553, 
        163,      354,      666,      933, 
        424,      341,      533,      870, 
        227,      730,      475,      186, 
        263,      647,      537,      686, 
        600,      224,      469,      68, 
        770,      919,      190,      373, 
        294,      822,      808,      206, 
        184,      943,      795,      384, 
        383,      461,      404,      758, 
        839,      887,      715,      67, 
        618,      276,      204,      918, 
        873,      777,      604,      560, 
        951,      160,      578,      722, 
        79,      804,      96,      409, 
        713,      940,      652,      934, 
        970,      447,      318,      353, 
        859,      672,      112,      785, 
        645,      863,      803,      350, 
        139,      93,      354,      99, 
        820,      908,      609,      772, 
        154,      274,      580,      184, 
        79,      626,      630,      742, 
        653,      282,      762,      623, 
        680,      81,      927,      626, 
        789,      125,      411,      521, 
        938,      300,      821,      78, 
        343,      175,      128,      250, 
        170,      774,      972,      275, 
        999,      639,      495,      78, 
        352,      126,      857,      956, 
        358,      619,      580,      124, 
        737,      594,      701,      612, 
        669,      112,      134,      694, 
        363,      992,      809,      743, 
        168,      974,      944,      375, 
        748,      52,      600,      747, 
        642,      182,      862,      81, 
        344,      805,      988,      739, 
        511,      655,      814,      334, 
        249,      515,      897,      955, 
        664,      981,      649,      113, 
        974,      459,      893,      228, 
        433,      837,      553,      268, 
        926,      240,      102,      654, 
        459,      51,      686,      754, 
        806,      760,      493,      403, 
        415,      394,      687,      700, 
        946,      670,      656,      610, 
        738,      392,      760,      799, 
        887,      653,      978,      321, 
        576,      617,      626,      502, 
        894,      679,      243,      440, 
        680,      879,      194,      572, 
        640,      724,      926,      56, 
        204,      700,      707,      151, 
        457,      449,      797,      195, 
        791,      558,      945,      679, 
        297,      59,      87,      824, 
        713,      663,      412,      693, 
        342,      606,      134,      108, 
        571,      364,      631,      212, 
        174,      643,      304,      329, 
        343,      97,      430,      751, 
        497,      314,      983,      374, 
        822,      928,      140,      206, 
        73,      263,      980,      736, 
        876,      478,      430,      305, 
        170,      514,      364,      692, 
        829,      82,      855,      953, 
        676,      246,      369,      970, 
        294,      750,      807,      827, 
        150,      790,      288,      923, 
        804,      378,      215,      828, 
        592,      281,      565,      555, 
        710,      82,      896,      831, 
        547,      261,      524,      462, 
        293,      465,      502,      56, 
        661,      821,      976,      991, 
        658,      869,      905,      758, 
        745,      193,      768,      550, 
        608,      933,      378,      286, 
        215,      979,      792,      961, 
        61,      688,      793,      644, 
        986,      403,      106,      366, 
        905,      644,      372,      567, 
        466,      434,      645,      210, 
        389,      550,      919,      135, 
        780,      773,      635,      389, 
        707,      100,      626,      958, 
        165,      504,      920,      176, 
        193,      713,      857,      265, 
        203,      50,      668,      108, 
        645,      990,      626,      197, 
        510,      357,      358,      850, 
        858,      364,      936,      638};
void randomiseBlock(void) 
{ int i ;
  int rNToGo ;
  int rTPos ;
  int tmp ;

  {
  rNToGo = 0;
  rTPos = 0;
  i = 0;
  while (i < 256) {
    inUse[i] = (unsigned char)0;
    i ++;
  }
  i = 0;
  while (i <= last) {
    if (rNToGo == 0) {
      rNToGo = rNums[rTPos];
      rTPos ++;
      if (rTPos == 512) {
        rTPos = 0;
      }
    }
    rNToGo --;
    if (rNToGo == 1) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    *(block + i) = (unsigned char )((int )*(block + i) ^ tmp);
    inUse[*(block + i)] = (unsigned char)1;
    i ++;
  }
  return;
}
}
void doReversibleTransformation(void) 
{ int i ;

  {
  if (verbosity >= 2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  }
  workLimit = workFactor * last;
  workDone = 0;
  blockRandomised = (unsigned char)0;
  firstAttempt = (unsigned char)1;
  sortIt();
  if (verbosity >= 3) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"      %d work, %d block, ratio %5.2f\n",
            workDone, last, (float )workDone / (float )last);
  }
  if (workDone > workLimit) {
    if (firstAttempt) {
      if (verbosity >= 2) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"    sorting aborted; randomising block\n");
      }
      randomiseBlock();
      workDone = 0;
      workLimit = workDone;
      blockRandomised = (unsigned char)1;
      firstAttempt = (unsigned char)0;
      sortIt();
      if (verbosity >= 3) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"      %d work, %d block, ratio %f\n",
                workDone, last, (float )workDone / (float )last);
      }
    }
  }
  origPtr = -1;
  i = 0;
  while (i <= last) {
    if (*(zptr + i) == 0) {
      origPtr = i;
      break;
    }
    i ++;
  }
  if (origPtr == -1) {
    panic((char *)"doReversibleTransformation");
  }
  return;
}
}
int indexIntoF(int indx , int *cftab ) 
{ int nb ;
  int na ;
  int mid ;

  {
  nb = 0;
  na = 256;
  while (1) {
    mid = (nb + na) >> 1;
    if (indx >= *(cftab + mid)) {
      nb = mid;
    } else {
      na = mid;
    }
    if (! (na - nb != 1)) {
      break;
    }
  }
  return (nb);
}
}
void undoReversibleTransformation_small(int dst ) 
{ int cftab[257] ;
  int cftabAlso[257] ;
  int i ;
  int j ;
  int tmp ;
  int tPos ;
  unsigned char ch ;
  int retVal ;
  int i2 ;
  int count ;
  int chPrev ;
  int ch2 ;
  unsigned int localCrc ;
  int rNToGo ;
  int rTPos ;
  int tmp___0 ;
  int j2 ;
  unsigned char z ;
  int tmp___1 ;
  int tmp___2 ;

  {
  cftab[0] = 0;
  i = 1;
  while (i <= 256) {
    cftab[i] = unzftab[i - 1];
    i ++;
  }
  i = 1;
  while (i <= 256) {
    cftab[i] += cftab[i - 1];
    i ++;
  }
  i = 0;
  while (i <= 256) {
    cftabAlso[i] = cftab[i];
    i ++;
  }
  i = 0;
  while (i <= last) {
    ch = (unsigned char )*(ll16 + i);
    *(ll16 + i) = (unsigned short )(cftabAlso[ch] & 65535);
    if ((i & 1) == 0) {
      *(ll4 + (i >> 1)) = (unsigned char )(((int )*(ll4 + (i >> 1)) & 240) | (cftabAlso[ch] >> 16));
    } else {
      *(ll4 + (i >> 1)) = (unsigned char )(((int )*(ll4 + (i >> 1)) & 15) | ((cftabAlso[ch] >> 16) << 4));
    }
    (cftabAlso[ch]) ++;
    i ++;
  }
  i = origPtr;
  j = (int )((unsigned int )*(ll16 + i) | ((((unsigned int )*(ll4 + (i >> 1)) >> ((i << 2) & 4)) & 15U) << 16));
  while (1) {
    tmp = (int )((unsigned int )*(ll16 + j) | ((((unsigned int )*(ll4 + (j >> 1)) >> ((j << 2) & 4)) & 15U) << 16));
    *(ll16 + j) = (unsigned short )(i & 65535);
    if ((j & 1) == 0) {
      *(ll4 + (j >> 1)) = (unsigned char )(((int )*(ll4 + (j >> 1)) & 240) | (i >> 16));
    } else {
      *(ll4 + (j >> 1)) = (unsigned char )(((int )*(ll4 + (j >> 1)) & 15) | ((i >> 16) << 4));
    }
    i = j;
    j = tmp;
    if (! (i != origPtr)) {
      break;
    }
  }
  tPos = origPtr;
  count = 0;
  i2 = 0;
  ch2 = 256;
  localCrc = getGlobalCRC();
  rNToGo = 0;
  rTPos = 0;
  while (i2 <= last) {
    chPrev = ch2;
    ch2 = indexIntoF(tPos, cftab);
    tPos = (int )((unsigned int )*(ll16 + tPos) | ((((unsigned int )*(ll4 + (tPos >> 1)) >> ((tPos << 2) & 4)) & 15U) << 16));
    if (blockRandomised) {
      if (rNToGo == 0) {
        rNToGo = rNums[rTPos];
        rTPos ++;
        if (rTPos == 512) {
          rTPos = 0;
        }
      }
      rNToGo --;
      if (rNToGo == 1) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
      ch2 = (int )((unsigned int )ch2 ^ (unsigned int )tmp___0);
    }
    i2 ++;
    if (dst) {
      retVal = spec_putc((unsigned char )ch2, dst);
    }
    localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
    if (ch2 != chPrev) {
      count = 1;
    } else {
      count ++;
      if (count >= 4) {
        tmp___1 = indexIntoF(tPos, cftab);
        z = (unsigned char )tmp___1;
        tPos = (int )((unsigned int )*(ll16 + tPos) | ((((unsigned int )*(ll4 + (tPos >> 1)) >> ((tPos << 2) & 4)) & 15U) << 16));
        if (blockRandomised) {
          if (rNToGo == 0) {
            rNToGo = rNums[rTPos];
            rTPos ++;
            if (rTPos == 512) {
              rTPos = 0;
            }
          }
          rNToGo --;
          if (rNToGo == 1) {
            tmp___2 = 1;
          } else {
            tmp___2 = 0;
          }
          z = (unsigned char )((int )z ^ tmp___2);
        }
        j2 = 0;
        while (j2 < (int )z) {
          if (dst) {
            retVal = spec_putc((unsigned char )ch2, dst);
          }
          localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
          j2 ++;
        }
        i2 ++;
        count = 0;
      }
    }
  }
  setGlobalCRC(localCrc);
  return;
}
}
void undoReversibleTransformation_fast(int dst ) 
{ int cftab[257] ;
  int i ;
  int tPos ;
  unsigned char ch ;
  int retVal ;
  int i2 ;
  int count ;
  int chPrev ;
  int ch2 ;
  unsigned int localCrc ;
  int rNToGo ;
  int rTPos ;
  int tmp ;
  int j2 ;
  unsigned char z ;
  int tmp___0 ;
  int j2___0 ;
  unsigned char z___0 ;

  {
  cftab[0] = 0;
  i = 1;
  while (i <= 256) {
    cftab[i] = unzftab[i - 1];
    i ++;
  }
  i = 1;
  while (i <= 256) {
    cftab[i] += cftab[i - 1];
    i ++;
  }
  i = 0;
  while (i <= last) {
    ch = *(ll8 + i);
    *(tt + cftab[ch]) = i;
    (cftab[ch]) ++;
    i ++;
  }
  tPos = *(tt + origPtr);
  count = 0;
  i2 = 0;
  ch2 = 256;
  localCrc = getGlobalCRC();
  if (blockRandomised) {
    rNToGo = 0;
    rTPos = 0;
    while (i2 <= last) {
      chPrev = ch2;
      ch2 = (int )*(ll8 + tPos);
      tPos = *(tt + tPos);
      if (rNToGo == 0) {
        rNToGo = rNums[rTPos];
        rTPos ++;
        if (rTPos == 512) {
          rTPos = 0;
        }
      }
      rNToGo --;
      if (rNToGo == 1) {
        tmp = 1;
      } else {
        tmp = 0;
      }
      ch2 = (int )((unsigned int )ch2 ^ (unsigned int )tmp);
      i2 ++;
      retVal = spec_putc((unsigned char )ch2, dst);
      localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
      if (ch2 != chPrev) {
        count = 1;
      } else {
        count ++;
        if (count >= 4) {
          z = *(ll8 + tPos);
          tPos = *(tt + tPos);
          if (rNToGo == 0) {
            rNToGo = rNums[rTPos];
            rTPos ++;
            if (rTPos == 512) {
              rTPos = 0;
            }
          }
          rNToGo --;
          if (rNToGo == 1) {
            tmp___0 = 1;
          } else {
            tmp___0 = 0;
          }
          z = (unsigned char )((int )z ^ tmp___0);
          j2 = 0;
          while (j2 < (int )z) {
            retVal = spec_putc((unsigned char )ch2, dst);
            localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
            j2 ++;
          }
          i2 ++;
          count = 0;
        }
      }
    }
  } else {
    while (i2 <= last) {
      chPrev = ch2;
      ch2 = (int )*(ll8 + tPos);
      tPos = *(tt + tPos);
      i2 ++;
      retVal = spec_putc((unsigned char )ch2, dst);
      localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
      if (ch2 != chPrev) {
        count = 1;
      } else {
        count ++;
        if (count >= 4) {
          z___0 = *(ll8 + tPos);
          tPos = *(tt + tPos);
          j2___0 = 0;
          while (j2___0 < (int )z___0) {
            retVal = spec_putc((unsigned char )ch2, dst);
            localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
            j2___0 ++;
          }
          i2 ++;
          count = 0;
        }
      }
    }
  }
  setGlobalCRC(localCrc);
  return;
}
}
int getRLEpair(int src ) 
{ int runLength ;
  int ch ;
  int chLatest ;
  int tmp ;
  int i ;

  {
  ch = spec_getc(src);
  if (ch == -1) {
    return ((1 << 16) | 257);
  }
  runLength = 0;
  while (1) {
    chLatest = spec_getc(src);
    runLength ++;
    bytesIn ++;
    if (ch == chLatest) {
      if (! (runLength < 255)) {
        break;
      }
    } else {
      break;
    }
  }
  if (chLatest != -1) {
    tmp = spec_ungetc((unsigned char )chLatest, src);
    if (tmp == -1) {
      panic((char *)"getRLEpair: ungetc failed");
    }
  }
  if (runLength == 1) {
    globalCrc = (globalCrc << 8) ^ crc32Table[(globalCrc >> 24) ^ (unsigned int )((unsigned char )ch)];
    return ((1 << 16) | ch);
  } else {
    i = 1;
    while (i <= runLength) {
      globalCrc = (globalCrc << 8) ^ crc32Table[(globalCrc >> 24) ^ (unsigned int )((unsigned char )ch)];
      i ++;
    }
    return ((runLength << 16) | ch);
  }
}
}
void loadAndRLEsource(int src ) 
{ int ch ;
  int allowableBlockSize ;
  int i ;
  int rlePair ;
  int runLen ;

  {
  last = -1;
  ch = 0;
  i = 0;
  while (i < 256) {
    inUse[i] = (unsigned char)0;
    i ++;
  }
  allowableBlockSize = 100000 * blockSize100k - 20;
  while (1) {
    if (last < allowableBlockSize) {
      if (! (ch != 257)) {
        break;
      }
    } else {
      break;
    }
    rlePair = getRLEpair(src);
    ch = rlePair & 65535;
    runLen = (int )((unsigned int )rlePair >> 16);
    if (ch != 257) {
      inUse[ch] = (unsigned char)1;
      switch (runLen) {
      case 1: 
      last ++;
      *(block + last) = (unsigned char )ch;
      break;
      case 2: 
      last ++;
      *(block + last) = (unsigned char )ch;
      last ++;
      *(block + last) = (unsigned char )ch;
      break;
      case 3: 
      last ++;
      *(block + last) = (unsigned char )ch;
      last ++;
      *(block + last) = (unsigned char )ch;
      last ++;
      *(block + last) = (unsigned char )ch;
      break;
      default: 
      inUse[runLen - 4] = (unsigned char)1;
      last ++;
      *(block + last) = (unsigned char )ch;
      last ++;
      *(block + last) = (unsigned char )ch;
      last ++;
      *(block + last) = (unsigned char )ch;
      last ++;
      *(block + last) = (unsigned char )ch;
      last ++;
      *(block + last) = (unsigned char )(runLen - 4);
      break;
      }
    }
  }
  return;
}
}
void compressStream(int stream , int zStream ) 
{ int retVal ;
  unsigned int blockCRC ;
  unsigned int combinedCRC ;
  int blockNo ;
  char const   *tmp ;

  {
  blockNo = 0;
  bytesIn = 0U;
  bytesOut = 0U;
  nBlocksRandomised = 0;
  bsSetStream(zStream, (unsigned char)1);
  bsPutUChar((unsigned char )'B');
  bsPutUChar((unsigned char )'Z');
  bsPutUChar((unsigned char )'h');
  bsPutUChar((unsigned char )(48 + blockSize100k));
  combinedCRC = 0U;
  if (verbosity >= 2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  }
  while (1) {
    blockNo ++;
    initialiseCRC();
    loadAndRLEsource(stream);
    if (last == -1) {
      break;
    }
    blockCRC = getFinalCRC();
    combinedCRC = (combinedCRC << 1) | (combinedCRC >> 31);
    combinedCRC ^= blockCRC;
    if (verbosity >= 2) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"    block %d: crc = 0x%8x, combined CRC = 0x%8x, size = %d",
              blockNo, blockCRC, combinedCRC, last + 1);
    }
    doReversibleTransformation();
    bsPutUChar((unsigned char)49);
    bsPutUChar((unsigned char)65);
    bsPutUChar((unsigned char)89);
    bsPutUChar((unsigned char)38);
    bsPutUChar((unsigned char)83);
    bsPutUChar((unsigned char)89);
    bsPutUInt32(blockCRC);
    if (blockRandomised) {
      bsW(1, 1U);
      nBlocksRandomised ++;
    } else {
      bsW(1, 0U);
    }
    moveToFrontCodeAndSend();
  }
  if (verbosity >= 2) {
    if (nBlocksRandomised > 0) {
      if (nBlocksRandomised == 1) {
        tmp = "";
      } else {
        tmp = "s";
      }
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"    %d block%s needed randomisation\n",
              nBlocksRandomised, tmp);
    }
  }
  bsPutUChar((unsigned char)23);
  bsPutUChar((unsigned char)114);
  bsPutUChar((unsigned char)69);
  bsPutUChar((unsigned char)56);
  bsPutUChar((unsigned char)80);
  bsPutUChar((unsigned char)144);
  bsPutUInt32(combinedCRC);
  if (verbosity >= 2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"    final combined CRC = 0x%x\n   ",
            combinedCRC);
  }
  bsFinishedWithStream();
  retVal = 0;
  if (retVal == -1) {
    ioError();
  }
  retVal = 0;
  if (retVal == -1) {
    ioError();
  }
  retVal = 0;
  if (retVal == -1) {
    ioError();
  }
  if (bytesIn == 0U) {
    bytesIn = 1U;
  }
  if (bytesOut == 0U) {
    bytesOut = 1U;
  }
  if (verbosity >= 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%6.3f:1, %6.3f bits/byte, %5.2f%% saved, %d in, %d out.\n",
            (float )bytesIn / (float )bytesOut, (8.0 * (double )((float )bytesOut)) / (double )((float )bytesIn),
            100.0 * (1.0 - (double )((float )bytesOut / (float )bytesIn)), bytesIn,
            bytesOut);
  }
  return;
}
}
unsigned char uncompressStream(int zStream , int stream ) 
{ unsigned char magic1 ;
  unsigned char magic2 ;
  unsigned char magic3 ;
  unsigned char magic4 ;
  unsigned char magic5 ;
  unsigned char magic6 ;
  unsigned int storedBlockCRC ;
  unsigned int storedCombinedCRC ;
  unsigned int computedBlockCRC ;
  unsigned int computedCombinedCRC ;
  int currBlockNo ;
  int retVal ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  bsSetStream(zStream, (unsigned char)0);
  magic1 = bsGetUChar();
  magic2 = bsGetUChar();
  magic3 = bsGetUChar();
  magic4 = bsGetUChar();
  if ((int )magic1 != 66) {
    goto _L;
  } else {
    if ((int )magic2 != 90) {
      goto _L;
    } else {
      if ((int )magic3 != 104) {
        goto _L;
      } else {
        if ((int )magic4 < 49) {
          goto _L;
        } else {
          if ((int )magic4 > 57) {
            _L: /* CIL Label */ 
            bsFinishedWithStream();
            retVal = 0;
            if (retVal == -1) {
              ioError();
            }
            return ((unsigned char)0);
          }
        }
      }
    }
  }
  setDecompressStructureSizes((int )magic4 - 48);
  computedCombinedCRC = 0U;
  if (verbosity >= 2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n    ");
  }
  currBlockNo = 0;
  while (1) {
    magic1 = bsGetUChar();
    magic2 = bsGetUChar();
    magic3 = bsGetUChar();
    magic4 = bsGetUChar();
    magic5 = bsGetUChar();
    magic6 = bsGetUChar();
    if ((int )magic1 == 23) {
      if ((int )magic2 == 114) {
        if ((int )magic3 == 69) {
          if ((int )magic4 == 56) {
            if ((int )magic5 == 80) {
              if ((int )magic6 == 144) {
                break;
              }
            }
          }
        }
      }
    }
    if ((int )magic1 != 49) {
      badBlockHeader();
    } else {
      if ((int )magic2 != 65) {
        badBlockHeader();
      } else {
        if ((int )magic3 != 89) {
          badBlockHeader();
        } else {
          if ((int )magic4 != 38) {
            badBlockHeader();
          } else {
            if ((int )magic5 != 83) {
              badBlockHeader();
            } else {
              if ((int )magic6 != 89) {
                badBlockHeader();
              }
            }
          }
        }
      }
    }
    tmp = bsGetUInt32();
    storedBlockCRC = (unsigned int )tmp;
    tmp___0 = bsR(1);
    if (tmp___0 == 1U) {
      blockRandomised = (unsigned char)1;
    } else {
      blockRandomised = (unsigned char)0;
    }
    currBlockNo ++;
    if (verbosity >= 2) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[%d: huff+mtf ",
              currBlockNo);
    }
    getAndMoveToFrontDecode();
    initialiseCRC();
    if (verbosity >= 2) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"rt+rld");
    }
    if (smallMode) {
      undoReversibleTransformation_small(stream);
    } else {
      undoReversibleTransformation_fast(stream);
    }
    computedBlockCRC = getFinalCRC();
    if (verbosity >= 3) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" {0x%x, 0x%x}",
              storedBlockCRC, computedBlockCRC);
    }
    if (verbosity >= 2) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"] ");
    }
    if (storedBlockCRC != computedBlockCRC) {
      crcError(storedBlockCRC, computedBlockCRC);
    }
    computedCombinedCRC = (computedCombinedCRC << 1) | (computedCombinedCRC >> 31);
    computedCombinedCRC ^= computedBlockCRC;
  }
  if (verbosity >= 2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n    ");
  }
  tmp___1 = bsGetUInt32();
  storedCombinedCRC = (unsigned int )tmp___1;
  if (verbosity >= 2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"combined CRCs: stored = 0x%x, computed = 0x%x\n    ",
            storedCombinedCRC, computedCombinedCRC);
  }
  if (storedCombinedCRC != computedCombinedCRC) {
    crcError(storedCombinedCRC, computedCombinedCRC);
  }
  bsFinishedWithStream();
  retVal = 0;
  if (retVal == -1) {
    ioError();
  }
  retVal = 0;
  if (retVal != 0) {
    ioError();
  }
  return ((unsigned char)1);
}
}
unsigned char testStream(int zStream ) 
{ unsigned char magic1 ;
  unsigned char magic2 ;
  unsigned char magic3 ;
  unsigned char magic4 ;
  unsigned char magic5 ;
  unsigned char magic6 ;
  unsigned int storedBlockCRC ;
  unsigned int storedCombinedCRC ;
  unsigned int computedBlockCRC ;
  unsigned int computedCombinedCRC ;
  int currBlockNo ;
  int retVal ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  bsSetStream(zStream, (unsigned char)0);
  magic1 = bsGetUChar();
  magic2 = bsGetUChar();
  magic3 = bsGetUChar();
  magic4 = bsGetUChar();
  if ((int )magic1 != 66) {
    bsFinishedWithStream();
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: bad magic number (ie, not created by bzip2)\n",
            inName);
    return ((unsigned char)0);
  } else {
    if ((int )magic2 != 90) {
      bsFinishedWithStream();
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: bad magic number (ie, not created by bzip2)\n",
              inName);
      return ((unsigned char)0);
    } else {
      if ((int )magic3 != 104) {
        bsFinishedWithStream();
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: bad magic number (ie, not created by bzip2)\n",
                inName);
        return ((unsigned char)0);
      } else {
        if ((int )magic4 < 49) {
          bsFinishedWithStream();
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: bad magic number (ie, not created by bzip2)\n",
                  inName);
          return ((unsigned char)0);
        } else {
          if ((int )magic4 > 57) {
            bsFinishedWithStream();
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: bad magic number (ie, not created by bzip2)\n",
                    inName);
            return ((unsigned char)0);
          }
        }
      }
    }
  }
  smallMode = (unsigned char)1;
  setDecompressStructureSizes((int )magic4 - 48);
  computedCombinedCRC = 0U;
  if (verbosity >= 2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  }
  currBlockNo = 0;
  while (1) {
    magic1 = bsGetUChar();
    magic2 = bsGetUChar();
    magic3 = bsGetUChar();
    magic4 = bsGetUChar();
    magic5 = bsGetUChar();
    magic6 = bsGetUChar();
    if ((int )magic1 == 23) {
      if ((int )magic2 == 114) {
        if ((int )magic3 == 69) {
          if ((int )magic4 == 56) {
            if ((int )magic5 == 80) {
              if ((int )magic6 == 144) {
                break;
              }
            }
          }
        }
      }
    }
    currBlockNo ++;
    if ((int )magic1 != 49) {
      bsFinishedWithStream();
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s, block %d: bad header (not == 0x314159265359)\n",
              inName, currBlockNo);
      return ((unsigned char)0);
    } else {
      if ((int )magic2 != 65) {
        bsFinishedWithStream();
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s, block %d: bad header (not == 0x314159265359)\n",
                inName, currBlockNo);
        return ((unsigned char)0);
      } else {
        if ((int )magic3 != 89) {
          bsFinishedWithStream();
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s, block %d: bad header (not == 0x314159265359)\n",
                  inName, currBlockNo);
          return ((unsigned char)0);
        } else {
          if ((int )magic4 != 38) {
            bsFinishedWithStream();
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s, block %d: bad header (not == 0x314159265359)\n",
                    inName, currBlockNo);
            return ((unsigned char)0);
          } else {
            if ((int )magic5 != 83) {
              bsFinishedWithStream();
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s, block %d: bad header (not == 0x314159265359)\n",
                      inName, currBlockNo);
              return ((unsigned char)0);
            } else {
              if ((int )magic6 != 89) {
                bsFinishedWithStream();
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s, block %d: bad header (not == 0x314159265359)\n",
                        inName, currBlockNo);
                return ((unsigned char)0);
              }
            }
          }
        }
      }
    }
    tmp = bsGetUInt32();
    storedBlockCRC = (unsigned int )tmp;
    tmp___0 = bsR(1);
    if (tmp___0 == 1U) {
      blockRandomised = (unsigned char)1;
    } else {
      blockRandomised = (unsigned char)0;
    }
    if (verbosity >= 2) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"    block [%d: huff+mtf ",
              currBlockNo);
    }
    getAndMoveToFrontDecode();
    initialiseCRC();
    if (verbosity >= 2) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"rt+rld");
    }
    undoReversibleTransformation_small(0);
    computedBlockCRC = getFinalCRC();
    if (verbosity >= 3) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" {0x%x, 0x%x}",
              storedBlockCRC, computedBlockCRC);
    }
    if (verbosity >= 2) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"] ");
    }
    if (storedBlockCRC != computedBlockCRC) {
      bsFinishedWithStream();
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s, block %d: computed CRC does not match stored one\n",
              inName, currBlockNo);
      return ((unsigned char)0);
    }
    if (verbosity >= 2) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ok\n");
    }
    computedCombinedCRC = (computedCombinedCRC << 1) | (computedCombinedCRC >> 31);
    computedCombinedCRC ^= computedBlockCRC;
  }
  tmp___1 = bsGetUInt32();
  storedCombinedCRC = (unsigned int )tmp___1;
  if (verbosity >= 2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"    combined CRCs: stored = 0x%x, computed = 0x%x\n    ",
            storedCombinedCRC, computedCombinedCRC);
  }
  if (storedCombinedCRC != computedCombinedCRC) {
    bsFinishedWithStream();
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: computed CRC does not match stored one\n",
            inName);
    return ((unsigned char)0);
  }
  bsFinishedWithStream();
  retVal = 0;
  if (retVal == -1) {
    ioError();
  }
  return ((unsigned char)1);
}
}
void cadvise(void) 
{ 

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nIt is possible that the compressed file(s) have become corrupted.\nYou can use the -tvv option to test integrity of such files.\n\nYou can use the `bzip2recover\' program to *attempt* to recover\ndata from undamaged sections of corrupted files.\n\n");
  return;
}
}
void showFileNames(void) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
  if ((unsigned int )(outName) == (unsigned int )((void *)0)) {
    tmp = "(null)";
  } else {
    tmp = (char const   *)(outName);
  }
  if ((unsigned int )(inName) == (unsigned int )((void *)0)) {
    tmp___0 = "(null)";
  } else {
    tmp___0 = (char const   *)(inName);
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\tInput file = %s, output file = %s\n",
          tmp___0, tmp);
  return;
}
}
void cleanUpAndFail(int ec ) 
{ int retVal ;
  char const   *tmp ;

  {
  if (srcMode == 3) {
    if (opMode != 3) {
      if ((unsigned int )(outName) == (unsigned int )((void *)0)) {
        tmp = "(null)";
      } else {
        tmp = (char const   *)(outName);
      }
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Deleting output file %s, if it exists.\n",
              progName, tmp);
      retVal = remove((char const   *)(outName));
      if (retVal != 0) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: WARNING: deletion of output file (apparently) failed.\n",
                progName);
      }
    }
  }
  if (numFileNames > 0) {
    if (numFilesProcessed < numFileNames) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: WARNING: some files have not been processed:\n\t%d specified on command line, %d not processed yet.\n\n",
              progName, numFileNames, numFileNames - numFilesProcessed);
    }
  }
  exit(ec);
}
}
void panic(char *s ) 
{ 

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: PANIC -- internal consistency error:\n\t%s\n\tThis is a BUG.  Please report it to me at:\n\tjseward@acm.org\n",
          progName, s);
  showFileNames();
  cleanUpAndFail(3);
  return;
}
}
void badBGLengths(void) 
{ 

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: error when reading background model code lengths,\n\twhich probably means the compressed file is corrupted.\n",
          progName);
  showFileNames();
  cadvise();
  cleanUpAndFail(2);
  return;
}
}
void crcError(unsigned int crcStored , unsigned int crcComputed ) 
{ 

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: Data integrity error when decompressing.\n\tStored CRC = 0x%x, computed CRC = 0x%x\n",
          progName, crcStored, crcComputed);
  showFileNames();
  cadvise();
  cleanUpAndFail(2);
  return;
}
}
void compressedStreamEOF(void) 
{ 

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: Compressed file ends unexpectedly;\n\tperhaps it is corrupted?  *Possible* reason follows.\n",
          progName);
  perror((char const   *)progName);
  showFileNames();
  cadvise();
  cleanUpAndFail(2);
  return;
}
}
void ioError(void) 
{ 

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: I/O or other error, bailing out.  Possible reason follows.\n",
          progName);
  perror((char const   *)progName);
  showFileNames();
  cleanUpAndFail(1);
  return;
}
}
void blockOverrun(void) 
{ 

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: block overrun during decompression,\n\twhich probably means the compressed file\n\tis corrupted.\n",
          progName);
  showFileNames();
  cadvise();
  cleanUpAndFail(2);
  return;
}
}
void badBlockHeader(void) 
{ 

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: bad block header in the compressed file,\n\twhich probably means it is corrupted.\n",
          progName);
  showFileNames();
  cadvise();
  cleanUpAndFail(2);
  return;
}
}
void bitStreamEOF(void) 
{ 

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: read past the end of compressed data,\n\twhich probably means it is corrupted.\n",
          progName);
  showFileNames();
  cadvise();
  cleanUpAndFail(2);
  return;
}
}
void mySignalCatcher(int n ) 
{ 

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: Control-C (or similar) caught, quitting.\n",
          progName);
  cleanUpAndFail(1);
  return;
}
}
void mySIGSEGVorSIGBUScatcher(int n ) 
{ 

  {
  if (opMode == 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: Caught a SIGSEGV or SIGBUS whilst compressing,\n\twhich probably indicates a bug in bzip2.  Please\n\treport it to me at: jseward@acm.org\n",
            progName);
  } else {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: Caught a SIGSEGV or SIGBUS whilst decompressing,\n\twhich probably indicates that the compressed data\n\tis corrupted.\n",
            progName);
  }
  showFileNames();
  if (opMode == 1) {
    cleanUpAndFail(3);
  } else {
    cadvise();
    cleanUpAndFail(2);
  }
  return;
}
}
void uncompressOutOfMemory(int draw , int blockSize ) 
{ 

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: Can\'t allocate enough memory for decompression.\n\tRequested %d bytes for a block size of %d.\n\tTry selecting space-economic decompress (with flag -s)\n\tand failing that, find a machine with more memory.\n",
          progName, draw, blockSize);
  showFileNames();
  cleanUpAndFail(1);
  return;
}
}
void compressOutOfMemory(int draw , int blockSize ) 
{ 

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: Can\'t allocate enough memory for compression.\n\tRequested %d bytes for a block size of %d.\n\tTry selecting a small block size (with flag -s).\n",
          progName, draw, blockSize);
  showFileNames();
  cleanUpAndFail(1);
  return;
}
}
